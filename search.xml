<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>覆盖率</title>
    <url>/2020/%E8%A6%86%E7%9B%96%E7%8E%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“验证如果没有量化，那么就意味着没有尽头。”</p>
<a id="more"></a>
<p>伴随着复杂SoC系统的验证难度系数成倍增加，无论是定向测试还是随机测试，我们在验证的过程中终究需要回答两个问题：</p>
<blockquote>
<p>是否所有设计的功能在验证计划中都已经验证？</p>
<p>代码中的某些部分是否从未执行过？</p>
</blockquote>
<p>因此，引入覆盖率来作为验证过程的重要参考，用于衡量验证精度和完备性。</p>
<h2 id="覆盖率的种类"><a class="header-anchor" href="#覆盖率的种类"></a>覆盖率的种类</h2>
<hr>
<p>fig7.1</p>
<p>如上图所示，常见为两种分法：</p>
<ul>
<li>按照生成方式，分为隐性（implicit）和显性（Explicit）；</li>
<li>按照来自功能描述,还是设计实现,分为specification或者implementation</li>
</ul>
<p>因此，组合之后主要有代码覆盖率、断言覆盖率以及功能覆盖率分别处于不同象限中。</p>
<h2 id="代码覆盖率"><a class="header-anchor" href="#代码覆盖率"></a>代码覆盖率</h2>
<hr>
<p><strong>优势</strong>：由仿真工具自动收集，继而用来指出在测试程序中设计源代码哪些被激活触发，而哪些则一直处于非激活的状态。</p>
<p><strong>局限</strong>：覆盖率100%并不意味着足够的功能覆盖率。</p>
<p><strong>包括</strong>：</p>
<ul>
<li>跳转覆盖率（toggle），衡量寄存器跳转的次数（0–&gt;1,1–&gt;0）;</li>
<li>行覆盖率（statement/line）,衡量代码行有没有被执行；</li>
<li>分支覆盖率（branch），衡量条件语句（if/else,case,?:）分支执行情况；</li>
<li>条件覆盖率（condition/expression），衡量一些布尔表达式中各个条件真伪判断的执行轨迹；</li>
<li>状态机覆盖率（FSM），仿真工具可以自动识别状态机，因此可以状态机的执行情况，包括跳转次数、顺序等。</li>
</ul>
<h2 id="功能覆盖率"><a class="header-anchor" href="#功能覆盖率"></a>功能覆盖率</h2>
<hr>
<p>我们无法通过代码覆盖率来得知功能是否被实现了，因此需要显性地定义，将设计功能描述映射到与功能覆盖率中，从而量化功能验证。</p>
<p><strong>覆盖组（covergroup）</strong></p>
<p>覆盖组与类相似，可以多次例化。包含覆盖点（coverpoint）、选项（option）、形式参数（argument）和可选触发（trigger event）。</p>
<p>覆盖组可以采集任何可见的变量，比如程序或模块变量、接口信号或者设计中的任何信号。</p>
<p>更多地covergroup定义在类中，被称为嵌入式覆盖组声明，例如以下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> xyz;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] m_x;</span><br><span class="line">  <span class="keyword">int</span> m_y;</span><br><span class="line">  <span class="keyword">bit</span> m_z;</span><br><span class="line">  <span class="keyword">covergroup</span> cov1 @m_z; <span class="comment">// embedded covergroup</span></span><br><span class="line">    <span class="keyword">coverpoint</span> m_x;</span><br><span class="line">    <span class="keyword">coverpoint</span> m_y;</span><br><span class="line">  <span class="keyword">endgroup</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(); cov1 = <span class="keyword">new</span>; <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p><strong>覆盖点（coverpoint）</strong></p>
<p>覆盖组中可以包含多个覆盖点（coverpoint），coverpoint可以对应多个bin（仓）。</p>
<p>下面的代码中 覆盖组cg包含多个覆盖点例如b、cx、e以及匿名覆盖点和交叉覆盖点。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg ( <span class="keyword">ref</span> <span class="keyword">int</span> x , <span class="keyword">ref</span> <span class="keyword">int</span> y, <span class="keyword">input</span> <span class="keyword">int</span> c);</span><br><span class="line">  <span class="keyword">coverpoint</span> x; <span class="comment">// 创建CP x</span></span><br><span class="line">  b: <span class="keyword">coverpoint</span> y; <span class="comment">// 创建CP b</span></span><br><span class="line">  cx: <span class="keyword">coverpoint</span> x; <span class="comment">// 创建CP cx</span></span><br><span class="line">  option<span class="variable">.weight</span> = c; </span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] d: <span class="keyword">coverpoint</span> y[<span class="number">31</span>:<span class="number">24</span>]; <span class="comment">// 创建CP d</span></span><br><span class="line">  e: <span class="keyword">coverpoint</span> x &#123;</span><br><span class="line">    option<span class="variable">.weight</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">cross</span> x, y &#123; <span class="comment">// 创建crossCP xXy</span></span><br><span class="line">    option<span class="variable">.weight</span> = c; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<p><strong>仓（bin）</strong></p>
<p>该关键字用于指定或对应所有感兴趣的数值或者取值范围。</p>
<p>除了覆盖数值外，还可以覆盖数值的变化。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">4</span>:<span class="number">1</span>] v_a;</span><br><span class="line"><span class="keyword">covergroup</span> cg @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  <span class="keyword">coverpoint</span> v_a &#123;</span><br><span class="line">    <span class="keyword">bins</span> sa = (<span class="number">4</span> =&gt; <span class="number">5</span> =&gt; <span class="number">6</span>), ([<span class="number">7</span>:<span class="number">9</span>],<span class="number">10</span>=&gt;<span class="number">11</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">bins</span> sb[] = (<span class="number">4</span>=&gt; <span class="number">5</span> =&gt; <span class="number">6</span>), ([<span class="number">7</span>:<span class="number">9</span>],<span class="number">10</span>=&gt;<span class="number">11</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">bins</span> sc = (<span class="number">12</span> =&gt; <span class="number">3</span> [-&gt; <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<p><strong>交叉覆盖率（cross）</strong></p>
<p>覆盖组中多个覆盖点或者变量之间可以另外定义交叉覆盖率（cover coverage）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个coverpoint交叉以后将生成256个交叉的bin</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line"><span class="keyword">covergroup</span> cov @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  aXb : <span class="keyword">cross</span> a, b;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog 线程控制</title>
    <url>/2020/SystemVerilog-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>介绍SV中的任务和函数，线程控制和线程间的同步和通信的基本概念</p>
<a id="more"></a>
<h2 id="任务和函数"><a class="header-anchor" href="#任务和函数"></a>任务和函数</h2>
<hr>
<h3 id="函数（function）"><a class="header-anchor" href="#函数（function）"></a>函数（function）</h3>
<p>首要目的在于为运算表达式提供返回值，其次可以简化代码，使得大型代码的维护更加容易。</p>
<p>函数的参数列表主要有input、output、inout和ref。</p>
<p><strong>函数的返回方式包括return直接返回，或者将值赋给与函数同名的变量。</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">15</span>:<span class="number">0</span>] myfunc1 (<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,y);</span><br><span class="line">  myfunc1 = x * y - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">function</span> [<span class="number">15</span>:<span class="number">0</span>] myfunc2 (<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,y);</span><br><span class="line">  <span class="keyword">return</span> x * y - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p>如果调用具有返回值的函数，但是又不使用该返回值，可以添加void’()进行转换。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>'(some_function());</span><br></pre></td></tr></table></figure>
<h3 id="任务（task）"><a class="header-anchor" href="#任务（task）"></a>任务（task）</h3>
<p>任务的定义同样可以指定函数中包括的各种参数，但任务可以消耗仿真时间。同时，任务可以调用其它任务或者函数。</p>
<p>task没有返回值，但我们依然可以利用return来使task结束。</p>
<h3 id="二者区别"><a class="header-anchor" href="#二者区别"></a>二者区别</h3>
<ul>
<li>function不会消耗仿真时间，而task则可能会消耗仿真时间；</li>
<li>function无法调用task，而task可以调用function；</li>
<li>一个可以返回数据的function只能返回一个单一数值，而任务或者void function不会返回数值；</li>
<li>一个可以返回数据的function可以作为一个表达式中的操作数，该操作数的值即function的返回值。</li>
</ul>
<h3 id="参数传递"><a class="header-anchor" href="#参数传递"></a>参数传递</h3>
<p>参数传递的过程只发生在方法的调用和返回时。</p>
<p><strong>ref参数在传递时不会发生值拷贝，而是将变量“指针”传递到方法中，在方法内部对该参数的操作将会同时影响外部变量。</strong></p>
<p>如果为了避免外部传入的ref参数会被方法修改，则可以添加const修饰符，来表示变量是只读变量。</p>
<p>SV中允许参数声明自己的默认值。方法被调用时，可由参数位置顺序在调用方法时传递参数，也可以由参数名字调用方式时绑定参数。</p>
<h2 id="线程控制"><a class="header-anchor" href="#线程控制"></a>线程控制</h2>
<hr>
<p><strong>并行线程</strong></p>
<p>Verilog中与顺序线程begin…end相对的是并行线程fork…join，SV引入了两种新的创建线程的方法，fork…join_none和fork…join_any。</p>
<p><img src="https://i.loli.net/2020/04/17/a3kyPvwTEzx7KjQ.png" alt="SV线程控制6.1.png"></p>
<p>fork…join需要所有并行的线程都结束以后才会继续执行;</p>
<p>fork…join_any则会等到任何一个线程结束以后就继续执行;</p>
<p>fork…join_none则不会等待其子线程而继续执行。</p>
<p>对于并行线程中，例如fork…join_any和fork…join_none继续执行后，未完成的后台子程序，可以通过使用wait fork或disable fork来等待或者终止这些子程序。</p>
<p><strong>时序控制</strong></p>
<p>SV可以通过延迟控制或者事件等待来对过程块完成时序控制。</p>
<ul>
<li>
<p>延迟控制即通过#来完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#10 rega &#x3D; regb;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>时间（event）控制即通过@来完成</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">@r rega = regb;</span><br><span class="line">@(<span class="keyword">posedge</span> clock) rega = regb;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>wait语句也可以与事件或者表达式结合来完成</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">real</span> AOR[];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">wait</span>(AOR<span class="variable">.size</span>() &gt; <span class="number">0</span>)...;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程的同步和通信"><a class="header-anchor" href="#线程的同步和通信"></a>线程的同步和通信</h2>
<hr>
<p>测试平台中的所有线程都需要同步并交换数据。例如，一个线程等待另外一个，验证环境需要等待所有激励结束、比较结束才可以结束仿真。又有，监测器需要将监测到的数据发送至比较器，比较器又需要从不同的缓存获取数据进行比较。</p>
<h3 id="事件（event）"><a class="header-anchor" href="#事件（event）"></a>事件（event）</h3>
<p>event可以用来控制进程的同步。</p>
<p>一般通过使用event来声明event变量，通过-&gt;来触发事件。其他等待该事件的进程可以通过@操作符或者wait()来检查event触发状态来完成。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> done, blast; <span class="comment">// declare two new events</span></span><br><span class="line"><span class="keyword">event</span> done_too = done; <span class="comment">// done_too as alias to done</span></span><br><span class="line"><span class="keyword">task</span> trigger( <span class="keyword">event</span> ev );</span><br><span class="line">  -&gt; ev;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">  @ done_too; <span class="comment">// wait for done through done_too</span></span><br><span class="line">  #<span class="number">1</span> trigger( done ); <span class="comment">// trigger done</span></span><br><span class="line"><span class="keyword">join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">  -&gt; blast;</span><br><span class="line">  <span class="keyword">wait</span> ( blast<span class="variable">.triggered</span> );</span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></table></figure>
<h3 id="wait-order-方法"><a class="header-anchor" href="#wait-order-方法"></a>wait_order()方法</h3>
<p>对于较多的事件时，wait_order可以使得进程保持等待，直到在参数列表中的事件event按照顺序从左到右依次完成。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wait_order</span>( a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wait_order</span>( a, b, c ) <span class="keyword">else</span> <span class="built_in">$display</span>( <span class="string">"Error: events out of order"</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">bit</span> success;</span><br><span class="line"><span class="keyword">wait_order</span>( a, b, c ) success = <span class="number">1</span>; <span class="keyword">else</span> success = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="旗语（semaphore）"><a class="header-anchor" href="#旗语（semaphore）"></a>旗语（semaphore）</h3>
<p>多个线程对同一资源进行访问时，使用旗语来实现对同一资源的访问控制，也称为“互斥访问”。其可以确保线程A在访问的时候，线程B是无法访问的，A退出后，B才可以访问。</p>
<p>旗语的基本操作包括：</p>
<ul>
<li>new方法创建一个带单个或多个钥匙的旗语；</li>
<li>get获取一个或多个钥匙；</li>
<li>put则可以返回一个或多个钥匙</li>
</ul>
<p>如果试图获取一个旗语而不被阻塞，则可以使用try_get()函数，返回1则表示有足够的钥匙。</p>
<p>如果一个线程请求“钥匙”不足，则会一直阻塞，多个阻塞的线程会以先进先出（FIFO）的方式进行排队。</p>
<h3 id="信箱（mailbox）"><a class="header-anchor" href="#信箱（mailbox）"></a>信箱（mailbox）</h3>
<p>信箱mailbox可以使得进程之间的信息得以交换，数据可以由一个进程写入信箱，再由另外一个进程获得。</p>
<p><strong>信箱的内建方法：</strong></p>
<ul>
<li>创建信箱：new()</li>
<li>将信息写入信箱：put()，试着写入信箱但不会阻塞：try_put()</li>
<li>获取信息：get()同时会取出数据，peek()不会取出数据</li>
<li>试着从信箱取出数据但不会阻塞：try_get()/try_peek()</li>
<li>获取信箱信息的数目：num()</li>
</ul>
<p>信箱的参数设置，没有指定参数时可以存放任何类型的数据，但一般不推荐这种操作。参数化信箱的方式可以使得在编译时就能够检查出类型不匹配的情况。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> mailbox <span class="variable">#(string)</span> s_mbox;</span><br><span class="line">s_mbox sm = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">string</span> s;</span><br><span class="line">sm<span class="variable">.put</span>( <span class="string">"hello"</span> );</span><br><span class="line">...</span><br><span class="line">sm<span class="variable">.get</span>( s ); <span class="comment">// s &lt;- "hello"</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog 随机约束</title>
    <url>/2020/SystemVerilog-%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>随着设计变得越来越大，要产生一个完整的激励来测试设计的功能也变得越来越困难。随机-约束，两个词组合在一起就构成了目前动态仿真验证的主流方法。</p>
<a id="more"></a>
<p>随机约束测试（CRT，Constrained-Random Test）即能够产生你感兴趣的、你想不到的的测试向量，通过回归测试、替换随机种子的方式来提高单位测试用例的覆盖率收集效率。</p>
<p>面向DUT的随机激励产生过程中，为了符合协议、满足测试需求，我们需要添加一些“约束”，从而系统地组织随机变量。同时，采用类来作为载体来容纳这些变量和它们之间的约束，类的成员变量均可声明为“随机”属性，用rand或者randc来表示。</p>
<h2 id="随机变量"><a class="header-anchor" href="#随机变量"></a>随机变量</h2>
<hr>
<h3 id="修饰符rand-randc"><a class="header-anchor" href="#修饰符rand-randc"></a>修饰符rand/randc</h3>
<ul>
<li>
<p>rand修饰符，表示在可生成的范围内，每个值的可能性是相同的</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] y;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>randc修饰符，其值会随机并且遍历其可取值范围。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] y;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/16/GMmdreoPKTt5N6u.png" alt="SV随机约束5.1.png"></p>
</li>
</ul>
<h3 id="使用范围"><a class="header-anchor" href="#使用范围"></a>使用范围</h3>
<ul>
<li>任何类中的整形（bit/byte/int）变量都可以声明为rand/randc；</li>
<li>定长数组、动态数组、关联数组和队列都可以声明为rand/randc，可以对动态数组和队列的长度加以约束；</li>
<li>指向对象的句柄成员，也可以声明为rand(不能被声明为randc)，随机时该句柄指向对象中的随机变量也会一并被随机；</li>
<li>非组合型结构体可以声明为rand，非组合型的成员可以声明为rand/randc；</li>
</ul>
<h2 id="随机约束"><a class="header-anchor" href="#随机约束"></a>随机约束</h2>
<hr>
<p>没有约束的随机变量会包含许多无效的和非法的值，这会使得有效激励的产生变得低效。因此，需要使用约束块来定义随机变量的约束关系。</p>
<h3 id="约束块方法"><a class="header-anchor" href="#约束块方法"></a>约束块方法</h3>
<ul>
<li>
<p>成员集合，约束块支持整形通过set操作符来设置他们的可取值范围</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> x, y, z;</span><br><span class="line"><span class="keyword">constraint</span> c1 &#123;x <span class="keyword">inside</span> &#123;<span class="number">3</span>, <span class="number">5</span>, [<span class="number">9</span>:<span class="number">15</span>], [<span class="number">24</span>:<span class="number">32</span>], [y:<span class="number">2</span>*y], z&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> a, b, c;</span><br><span class="line"><span class="keyword">constraint</span> c2 &#123;a <span class="keyword">inside</span> &#123;b, c&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> fives[<span class="number">4</span>] = '&#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> v;</span><br><span class="line"><span class="keyword">constraint</span> c3 &#123; v <span class="keyword">inside</span> &#123;fives&#125;; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>权重分布，可支持设置可取值的同时为其设置随机时的权重</p>
<p>使用:=操作符，表示每个值的固定权重值；使用:/操作符，表示权重会平均分配到每一个值。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x在100,101,102,200和300的权重是1-1-1-2-5。</span></span><br><span class="line">x <span class="keyword">dist</span> &#123; [<span class="number">100</span>:<span class="number">102</span>] := <span class="number">1</span>, <span class="number">200</span> := <span class="number">2</span>, <span class="number">300</span> := <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x在100,101,102,200和300的权重是1/3-1/3-1/3-2-5。</span></span><br><span class="line">x <span class="keyword">dist</span> &#123; [<span class="number">100</span>:<span class="number">102</span>] :/ <span class="number">1</span>, <span class="number">200</span> := <span class="number">2</span>, <span class="number">300</span> := <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>唯一标识，unique可以用来约束一组变量，使其在随机后变量之间不会有相同的数值</p>
</li>
<li>
<p>条件约束，可以使用if-else或者-&gt;操作符来表示条件约束</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> c1&#123;</span><br><span class="line">    mode == little -&gt; len &lt; <span class="number">10</span>;</span><br><span class="line">    mode == big -&gt; len &gt; <span class="number">100</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line"><span class="keyword">constraint</span> c2 &#123; (a == <span class="number">0</span>) -&gt; (b == <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c3&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == little)</span><br><span class="line">        len &lt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == big)</span><br><span class="line">        len &gt; <span class="number">100</span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代约束，foreach可以用来迭代约束数组中的元素，这些数组可以是定长数组、动态数组、关联数组或者队列；</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">byte</span> A[] ;</span><br><span class="line">  <span class="keyword">constraint</span> C1 &#123; <span class="keyword">foreach</span> (A[i]) A[i] <span class="keyword">inside</span> </span><br><span class="line">                  &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>&#125;;&#125;</span><br><span class="line">  <span class="keyword">constraint</span> C2 &#123; <span class="keyword">foreach</span> (A[j]) A[j] &gt; <span class="number">2</span> * j; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<p>对于某些数组，例如动态数组，也可以使用缩减的方法做迭代约束。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] A[] ;</span><br><span class="line">  <span class="keyword">constraint</span> c1 &#123; A<span class="variable">.size</span>() == <span class="number">5</span>; &#125;</span><br><span class="line">  <span class="keyword">constraint</span> c2 &#123; A<span class="variable">.sum</span>() &lt; <span class="number">1000</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[0] + A[1] + A[2] + A[3] + A[4] &lt; 1000</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数调用，可在约束块中调用函数来描述约束。例如，计算一个合并数组中的“1”的数量：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> count_ones ( <span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] w );</span><br><span class="line">  <span class="keyword">for</span>( count_ones = <span class="number">0</span>; w != <span class="number">0</span>; w = w &gt;&gt; <span class="number">1</span> )</span><br><span class="line">  count_ones += w &amp; <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在约束块中调用该函数来描述约束</span></span><br><span class="line"><span class="keyword">constraint</span> C1 &#123; length == count_ones( v ) ; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>软约束，没有soft描述时默认为硬约束，当约束冲突时，硬约束可以“覆盖”软约束，并且不会导致随机数产生的失败。</p>
</li>
</ul>
<h2 id="约束控制"><a class="header-anchor" href="#约束控制"></a>约束控制</h2>
<hr>
<h3 id="随机方法randomize"><a class="header-anchor" href="#随机方法randomize"></a>随机方法randomize()</h3>
<p>在类中声明的随机变量，需要伴随着**SV类的内建方法randomize()**的调用。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">int</span> randomize();</span><br></pre></td></tr></table></figure>
<p>如果随机化成功则返回1，如果失败则返回0。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> SimpleSum;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] x, y, z;</span><br><span class="line">  <span class="keyword">constraint</span> c &#123;z == x + y;&#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">SimpleSum p = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span> success = p<span class="variable">.randomize</span>();</span><br><span class="line"><span class="keyword">if</span> (success == <span class="number">1</span> ) ...</span><br></pre></td></tr></table></figure>
<p><strong>内嵌约束</strong>：在调用类方法randomize()时可以伴随着with来添加额外的约束。</p>
<p>内嵌约束可能存在指向模糊的问题。例如以下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C1;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> C2;</span><br><span class="line">  <span class="keyword">integer</span> x;</span><br><span class="line">  <span class="keyword">integer</span> y;</span><br><span class="line">  <span class="keyword">task</span> doit(C1 f, <span class="keyword">integer</span> x, <span class="keyword">integer</span> z);</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    result = f<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;x &lt; y + z;&#125;;</span><br><span class="line">  <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h3 id="内嵌约束指向模糊问题"><a class="header-anchor" href="#内嵌约束指向模糊问题"></a>内嵌约束指向模糊问题</h3>
<p><strong>解决指向模糊的问题，可以在随机时在with后面添加指定对象的成员变量</strong>，不在其中的则是该对象以外的变量。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> F(C obj, <span class="keyword">integer</span> y);</span><br><span class="line">  F = obj<span class="variable">.randomize</span>() <span class="keyword">with</span> (x) &#123; x &lt; y; &#125;;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<p><strong>可以通过local::的域索引方式来明确随机变量的指向</strong>，即local::指向的变量会在包含randomize()方法的对象中。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> x;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> F(C obj, <span class="keyword">integer</span> x);</span><br><span class="line">  F = obj<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; x &lt; <span class="keyword">local</span>::x; &#125;;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">//第一个x指向对象c中的成员变量x，第二个x指向c对象以外的域</span></span><br></pre></td></tr></table></figure>
<h2 id="随机控制"><a class="header-anchor" href="#随机控制"></a>随机控制</h2>
<hr>
<p><strong>随机变量的控制</strong></p>
<p>rand_mode可以用来使能或者禁止随机变量。</p>
<p>可以就单个随机变量调用其rand_mode，或者对整个对象调用rand_mode来控制其中所有的随机变量。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> object[<span class="variable">.random_variable</span>]::rand_mode( <span class="keyword">bit</span> on_off );</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> object<span class="variable">.random_variable</span>::rand_mode();</span><br></pre></td></tr></table></figure>
<p><strong>约束块的控制</strong></p>
<p>通过约束控制函数constraint_mode来使能或者关闭某些约束块。</p>
<p>一些约束块或者某个类的约束块集合也可以单个控制或者集体控制。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> object[<span class="variable">.constraint_identifier</span>]::constraint_mode(<span class="keyword">bit</span> on_off );</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> object<span class="variable">.constraint_identifier</span>::constraint_mode();</span><br></pre></td></tr></table></figure>
<p><strong>内嵌变量控制</strong></p>
<p>在使用类的随机化函数randomize()时，如果伴有参数，那么只会随机化这些变量，而其余变量无论是否之前被声明为rand/randc，都将不会参与到随机化当中。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> CA;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">byte</span> x, y;</span><br><span class="line">  <span class="keyword">byte</span> v, w;</span><br><span class="line">  <span class="keyword">constraint</span> c1 &#123; x &lt; v &amp;&amp; y &gt; w； &#125;;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">CA a = <span class="keyword">new</span>;</span><br><span class="line">a<span class="variable">.randomize</span>(); <span class="comment">// random variables: x, y </span></span><br><span class="line">a<span class="variable">.randomize</span>( x ); <span class="comment">// random variables: x </span></span><br><span class="line">a<span class="variable">.randomize</span>( v, w ); <span class="comment">// random variables: v, w</span></span><br><span class="line">a<span class="variable">.randomize</span>( w, x ); <span class="comment">// random variables: w, x</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog 类和包介绍</title>
    <url>/2020/SystemVerilog-%E7%B1%BB%E5%92%8C%E5%8C%85%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>类是一种可以包含数据和方法的类型。通过类的使用，实现面向对象编程（OOP，Object-Oriented Programming）…</p>
<a id="more"></a>
<h2 id="类的封装"><a class="header-anchor" href="#类的封装"></a>类的封装</h2>
<hr>
<p>类是一种可以包含数据和方法的类型。借助类的使用，实现面向对象编程（OOP，Object-Oriented Programming），用户可以创建复杂的数据类型，在更加抽象的层次建立测试平台和系统级模型，通过调用函数可以执行一个动作而不仅是完成电平的改变。</p>
<p><strong>OOP术语：</strong></p>
<ul>
<li>类（class）：包含成员变量和成员方法；</li>
<li>对象（object）：类在例化后的实例；</li>
<li>句柄（handle）：指向对象的指针；</li>
<li>原型（prototype）：程序的声明部分，包含程序名、返回类型和参数列表</li>
</ul>
<p><strong>如何创建一个类（class）？</strong></p>
<p>将class的声明和创建分开。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Transaction tr; <span class="comment">//声明一个句柄</span></span><br><span class="line">tr = <span class="keyword">new</span>(); <span class="comment">//为一个Transaction对象分配空间</span></span><br></pre></td></tr></table></figure>
<p>首先，为对象创建一个句柄，在声明时会被初始化为特殊值null。</p>
<p>接下来，调用构造函数new()函数来创建Transaction对象。new函数为Transaction分配空间，将变量初始化为默认值（二值变量为0，四值变量为X），并返回一个指向类对象的句柄，其类型就是类本身。</p>
<p><strong>赋值和拷贝</strong></p>
<ul>
<li>
<p>浅拷贝（shallow copy）与深拷贝（deep copy）</p>
<p>浅拷贝（shallow copy），在创建P2对象时，调用new函数进行复制，Packet 对象中的成员变量例如整数、字符串和句柄等被拷贝，但如果类中包含一个指向另一个类的句柄则不会被复制。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Packet P1;</span><br><span class="line">Packet P2;</span><br><span class="line">P1 = <span class="keyword">new</span>;</span><br><span class="line">P2 = <span class="keyword">new</span> P1;</span><br></pre></td></tr></table></figure>
<p>深拷贝（deep copy），对对象中的句柄指向的对象也做相应的拷贝，即做递归的拷贝。用户需要自己定义深拷贝的函数才能实现这种需求。</p>
<p>例如有下列代码，</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> rgb;</span><br><span class="line">    <span class="keyword">byte</span> red;</span><br><span class="line">    <span class="keyword">byte</span> green;</span><br><span class="line">    <span class="keyword">byte</span> blue;</span><br><span class="line"><span class="keyword">endclass</span>:rgb</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> pixel;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    </span><br><span class="line">    rgb color;</span><br><span class="line"><span class="keyword">endclass</span>:pixel</span><br><span class="line">pixel dot = <span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/04/13/bkE2rxFoIqsuCej.png" alt="SV类和包介绍4.1.png"></p>
<p>图中(a)，利用new函数拷贝对象时，只能对color句柄做拷贝，而不会对其指向的对象也做拷贝，因此拷贝的类和原先的pixel都指向同一rgb对象，属于浅拷贝（shallow copy）。</p>
</li>
</ul>
<p><strong>其他特征</strong></p>
<ul>
<li>静态成员（变量/方法）,类的成员默认是动态的，可添加关键字static创建共享的静态成员变量或者方法</li>
<li>使用this来索引当前所在对象的成员（变量/参数/方法）</li>
<li>数据的隐藏，使得类的测试和维护变得简单。例如local，protected</li>
</ul>
<h2 id="类的继承"><a class="header-anchor" href="#类的继承"></a>类的继承</h2>
<hr>
<p>SV中通过使用关键词extends，可以扩展一个新的类继承于先前定义过的类，包括其所有的成员（变量/方法）。</p>
<p><strong>成员的覆盖</strong></p>
<p>子类可以继承父类的成员。当父类句柄指向子类的对象时，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">LinkedPacket lp = <span class="keyword">new</span>;</span><br><span class="line">Packet p = lp;</span><br></pre></td></tr></table></figure>
<p>因为子类中声明了与父类同名的成员（变量/方法），其同名成员的访问都将指向子类，而父类的成员将被隐藏。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">integer</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">integer</span> get();</span><br><span class="line">    get = i;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LinkedPacket <span class="keyword">extends</span> Packet;</span><br><span class="line">  <span class="keyword">integer</span> i = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">integer</span> get();</span><br><span class="line">    get = -i;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">LinkedPacket lp = <span class="keyword">new</span>;</span><br><span class="line">Packet p = lp;</span><br><span class="line"></span><br><span class="line">j = p<span class="variable">.i</span>; <span class="comment">// j = 1, not 2</span></span><br><span class="line">j = p<span class="variable">.get</span>(); <span class="comment">// j = 1, not -1 or –2</span></span><br></pre></td></tr></table></figure>
<p><strong>super 的使用</strong></p>
<p>用于访问当前对象的父类成员，尤其当子类与父类的成员同名时，可以使用其指定访问父类成员，而非默认的子类成员。</p>
<h2 id="包的使用"><a class="header-anchor" href="#包的使用"></a>包的使用</h2>
<hr>
<p>为了使得可以在多个模块（硬件）或者类（软件）之间共享用户定义的类型，SV添加了包（package）。</p>
<p>module、interface、class等可以使用包中定义或者声明的内容。</p>
<p>可以通过域的索引符::号直接引用,或者通过通配符*来将包中所有的类别导入到指定容器中。</p>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog 数组介绍</title>
    <url>/2020/SystemVerilog-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是组合型数组？什么又是非组合型数组？</p>
<a id="more"></a>
<h2 id="组合型和非组合型数组"><a class="header-anchor" href="#组合型和非组合型数组"></a>组合型和非组合型数组</h2>
<hr>
<h3 id="非组合型（unpacked）"><a class="header-anchor" href="#非组合型（unpacked）"></a>非组合型（unpacked）</h3>
<p>verilog中通常定义例如<code>reg [15:0] RAM[0:4095];</code>，这种数组定义为memory array用作数据存储。SV将这种声明数组的方式称作非组合型数组，即数组中的成员之间存储数据都是互相独立的。</p>
<p>例如作以下定义：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] <span class="keyword">table</span> [<span class="number">3</span>:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>对应的存储结构为：</p>
<p><img src="https://i.loli.net/2020/04/11/PvsCz36pwLSZYrm.png" alt="SV数组介绍3.1.png"></p>
<h3 id="组合型（packed）"><a class="header-anchor" href="#组合型（packed）"></a>组合型（packed）</h3>
<p>SV中将具有向量结构的数组声明方式作为组合型。其相对于非组合型在声明时的差别在于，其索引在数组名的左侧，数组维度从左到右来识别。</p>
<p>例如作如下定义：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data;<span class="comment">//2维组合声明</span></span><br></pre></td></tr></table></figure>
<p>对应的存储结构为：</p>
<p><img src="https://i.loli.net/2020/04/11/kFmCXt6IansPUY1.png" alt="SV数组介绍3.2.png"></p>
<h3 id="区别分析"><a class="header-anchor" href="#区别分析"></a>区别分析</h3>
<p>初始化时，组合型（packed）存储值是连续的，可以对所有元素统一赋值；非组合型（unpacked）中则需要分别对每一个维度进行赋值。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//packed</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a = <span class="number">32</span>’h0; <span class="comment">// vector assignment</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] b = &#123;<span class="number">16</span>’hz,<span class="number">16</span>’h0&#125;; <span class="comment">// concatenate operator</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] c = &#123;<span class="number">16</span>&#123;<span class="number">2</span>’b01&#125;&#125;; <span class="comment">// replicate operator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unpacked</span></span><br><span class="line"><span class="keyword">int</span> d [<span class="number">0</span>:<span class="number">1</span>][<span class="number">0</span>:<span class="number">3</span>] = ’&#123; ’&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>&#125;, ’&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// d[0][0] = 7  d[0][1] = 3  d[0][2] = 0  d[0][3] = 5</span></span><br><span class="line"><span class="comment">// d[1][0] = 2  d[1][1] = 0  d[1][2] = 1  d[1][3] = 6</span></span><br></pre></td></tr></table></figure>
<p>非组合型数组中，若两个数组进行拷贝和赋值时，左右两边数组的维度和大小必须严格一致；组合型数组中，赋值左右两侧操作数的大小和维度不同时，也可以做赋值，会采用截取或者扩展的方式进行赋值。</p>
<p>非组合型和组合型之间无法直接地互相赋值。</p>
<h3 id="其他特性"><a class="header-anchor" href="#其他特性"></a>其他特性</h3>
<ul>
<li>
<p>添加了foreach循环结构，用于遍历一维或多维数组，不需要指定该数组的大小。</p>
</li>
<li>
<p>添加了系统函数，例如：</p>
<p><code>$dimensions(array_name)</code>,返回数组的维度；</p>
<p><code>$left(array_name,dimensions)</code>,返回指定维度的最左索引值；</p>
<p><code>$size(array_name,dimensions)</code>，返回指定维度的尺寸大小等等</p>
</li>
</ul>
<h2 id="其他数组类型"><a class="header-anchor" href="#其他数组类型"></a>其他数组类型</h2>
<hr>
<h3 id="动态数组"><a class="header-anchor" href="#动态数组"></a>动态数组</h3>
<p>动态数组在声明时使用“[]”，且不会为限制数组尺寸。动态数组一开始为空，使用new[]为其分配空间。同时，内建方法size(),delete()可以对动态数组进行操作。</p>
<h3 id="队列"><a class="header-anchor" href="#队列"></a>队列</h3>
<p>SV引入了队列，结合了数组和链表。通过“[$]”声明队列，索引值从0到$，常用的内建函数包括push_back(val)、push_front(val)、pop_back()和pop_front()来顺序添加或者移除并且获得数据成员。</p>
<h3 id="关联数组"><a class="header-anchor" href="#关联数组"></a>关联数组</h3>
<p>用于存放散列的数据成员，散列的索引类型除了为整形外还可以为字符串或者其它类型，散列的存储数据也可以为任意类型。</p>
<p><img src="https://i.loli.net/2020/04/11/J8IzFPNGb3Z52W1.png" alt="SV数组介绍3.3.png"></p>
<h2 id="数组操作方法"><a class="header-anchor" href="#数组操作方法"></a>数组操作方法</h2>
<hr>
<p>常见的包括以下几类：</p>
<ul>
<li>缩减方法，sum、product、and、or和xor；</li>
<li>定位方法，min、max和unique等，foreach实现数组搜索或者find…width查找满足条件的数据成员；</li>
<li>排序方法，reverse、sort、rsort和shuffle等。</li>
</ul>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog 语法基本类型</title>
    <url>/2020/SystemVerilog-%E8%AF%AD%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SystemVerilog中语法基本类型的简单介绍</p>
<a id="more"></a>
<h2 id="数据类型中四值-二值逻辑的区分"><a class="header-anchor" href="#数据类型中四值-二值逻辑的区分"></a>数据类型中四值&amp;二值逻辑的区分</h2>
<hr>
<p><strong>verilog中数据类型均为四值逻辑</strong>，包括变量类型（variables）和线网类型（nets）。</p>
<ul>
<li>
<p>variables类型包括例如reg、integer和time等，用来存储组合或者时序逻辑的值；</p>
</li>
<li>
<p>nets类型包括例如wire、wor和wand等，主要用于生成连线实现模块间连接以及提供特殊的线网逻辑解决方案等。</p>
</li>
</ul>
<p><strong>SystemVerilog将数据类型分为四值逻辑（logic）和二值逻辑（bit）。</strong></p>
<ul>
<li>四值逻辑硬件信号中变量或者线网类型，统一可以用logic声明。logic默认为变量类型（variable），也可以显示声明为线网型（nets）；</li>
<li>二值数据类型，用来对于比RTL更高抽象级的模型建模，这些模型中Z和X很少被使用。包括，bit(1-bit)/byte(8-bit)/shortint(16-bit)/int(32-bit)/longint(64-bit)。</li>
</ul>
<h2 id="自定义类型"><a class="header-anchor" href="#自定义类型"></a>自定义类型</h2>
<hr>
<p>SV中通过自定义类型使得代码自身的可读性更好，也使得用户可以构建更高抽象层的数据类型。常见的包括：</p>
<ul>
<li>typedef,创建用户自定义类型；</li>
<li>enum，创建枚举类型，描述变量的合法值范围；</li>
<li>struct，创建结构体类型。</li>
</ul>
<p>typedef又可以对enum，struct实现自定义枚举或结构体类型。</p>
<h2 id="字符串类型"><a class="header-anchor" href="#字符串类型"></a>字符串类型</h2>
<hr>
<p>SV引入了string类型来容纳可变长度的字符串，同时包括一些字符串内建的方法，例如返回字符串长度str.len(),返回地i个字符串str.getc(i)等等。</p>
<p>SV字符串类型有以下特点：</p>
<ul>
<li>存储单元为byte类型；</li>
<li>不同于c函数，没有空字符，长度为N，则索引为0~N-1；</li>
<li>内存是动态分配的</li>
</ul>
<h2 id="接口（interface）"><a class="header-anchor" href="#接口（interface）"></a>接口（interface）</h2>
<hr>
<p>verilog中模块之间的通信需要例化端口和连线来完成，大型的设计中大量的端口让设计冗长和容易出错。因此，SV在Verilog基础上扩展了接口（interface）。</p>
<p>接口提供了一种新型的对抽象级建模的方式，可以使简化建模和验证大型设计。</p>
<img src="https://i.loli.net/2020/04/11/iFX7IP4tlkGZsMh.png" alt="SV语法基本类型2.1.png" style="zoom:80%;" />
<p><strong>优势：</strong></p>
<ul>
<li>允许多个信号被整合到一起表示一个单一的抽象端口；</li>
<li>多个模块可以使用同一个interface，避免分散的多个端口信号连接；</li>
<li>验证中，利用接口可以将测试平台同DUT连接在一起。</li>
</ul>
<p>接口不同于模块（module）的地方在于，接口不允许包含设计层次，即接口无法例化module，但可以例化接口。进一步的，可以通过modport来约束不同模块连接时的信号方向。</p>
<p><strong>小结：</strong></p>
<ul>
<li>接口有利于设计复用，减少了模块之间错误连接的可能性；</li>
<li>如需添加新的信号，可直接在接口中声明。因此，使用信号时需要添加一个层次（接口实例名）；</li>
<li>接口一般将相关的信号集合在一起，设计中会包含多各接口实例。</li>
</ul>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>芯片验证概述</title>
    <url>/2020/%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>芯片验证为IC设计流程中前端设计的重要一环，用其来证明设计功能是否正确，是否符合设计功能描述。</p>
<a id="more"></a>
<p>验证和设计是协作进行的，验证和设计都需要认真阅读功能描述文档。设计将功能文档翻译为RTL模型，验证则会按照其功能发送激励和比较结果。</p>
<img src="https://i.loli.net/2020/04/07/KAmrWBp1lGdUZkY.png" alt="验证概述1.1.png" style="zoom: 67%;" />
<p><strong>验证的周期</strong></p>
<p>功能验证有着一整套完备的流程，从硬件系统定义贯穿到硅后测试部分。</p>
<p><img src="https://i.loli.net/2020/04/09/5eGZx9tBqIz8Xyk.png" alt="验证概述1.3.png"></p>
<h2 id="什么是验证测试平台？"><a class="header-anchor" href="#什么是验证测试平台？"></a>什么是验证测试平台？</h2>
<hr>
<p><img src="https://i.loli.net/2020/04/07/bHLy5WuARsGMhCK.png" alt="验证概述1.2.png"></p>
<p>如图所示，测试平台主要包括的模块有时钟/重置（clock/reset）、激励发生器（stimulator）、检测器（monitor）、比较器（checker）以及待测设计（DUT）。其中：</p>
<ul>
<li>Stimulator：对DUT创建测试序列</li>
<li>Monitor：观察DUT的输入输出</li>
<li>Checker：对DUT的输出数据与预期数据进行比对</li>
</ul>
<p>除此以外，clock/reset完成时钟的发起以及复位工作。最终，测试平台还会报告检查结果。</p>
<h2 id="什么是SystemVerilog？"><a class="header-anchor" href="#什么是SystemVerilog？"></a>什么是SystemVerilog？</h2>
<hr>
<p>SystemVerilog是一种新的硬件描述和验证语言（HDVL， Hardware Description and Verification Language）。</p>
<p><strong>SV语言的核心特性</strong></p>
<ul>
<li>接口（interface）</li>
<li>面向对象编程（class&amp;package）</li>
<li>约束随机（constrained random）</li>
<li>线程控制和通信（process control）</li>
<li>功能覆盖率（function coverage）</li>
<li>外部语言编程接口（Direct Programming Interface）</li>
<li>断言（assertion）</li>
</ul>
<h2 id="什么是UVM？"><a class="header-anchor" href="#什么是UVM？"></a>什么是UVM？</h2>
<hr>
<p>UVM（Universal Verification Methodology），是一种可适用于大多数项目的验证方法学。它自身提供的基础类库和验证结构可以让具有不同软件编程经验的验证工程师能够快速构建起一个可靠的验证框架；其框架构建类和测试类能够减轻环境构建的负担，进而将精力集中在如何制定验证计划和创建测试场景上。</p>
<p>学习UVM时，可以遵循以下步骤：</p>
<ul>
<li>认识UVM世界的版图（类库）和核心机制</li>
<li>学习核心的UVM组件和层次构建方式</li>
<li>了解常见的UVM组件间的通信方式</li>
<li>深入UVM测试场景的构成</li>
<li>UVM的寄存器模型应用</li>
</ul>
<p><strong>UVM的类大致包括以下几类：</strong></p>
<ul>
<li>核心基类</li>
<li>工厂（factory）类</li>
<li>事务（transaction）和序列（sequence）类</li>
<li>结构创建（structure creation）类</li>
<li>环境组件（environment component）类</li>
<li>通信管道（channel）类</li>
<li>信息报告（message report）类</li>
<li>寄存器模型（register model）类</li>
<li>线程同步（thread synchronization）类</li>
<li>事务接口（transaction interface）类</li>
</ul>
<hr>
<p><em>Reference</em>：</p>
<p>1.路科验证V0系列课程，可参考《芯片验证漫游指南：从理论到UVM的验证全视界》</p>
]]></content>
      <categories>
        <category>芯片验证基础</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
        <tag>UVM</tag>
      </tags>
  </entry>
  <entry>
    <title>状态机基础介绍</title>
    <url>/2020/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>状态机的本质是对具有逻辑顺序或时序规律事件的一种描述方法。</p>
<a id="more"></a>
<h2 id="状态机的基本概念"><a class="header-anchor" href="#状态机的基本概念"></a>状态机的基本概念</h2>
<hr>
<p><strong>应用思路</strong>：</p>
<ul>
<li>
<p>从状态变量入手</p>
<p>根据电路的时序规律或者逻辑顺序，规划状态，分析状态的输入、转移及输出</p>
</li>
<li>
<p>明确电路的输出关系，这些输出对应于状态的输出，进而回溯规划每个状态和状态转移条件及输入</p>
</li>
</ul>
<p><strong>基本要素</strong>：状态、输出、输入</p>
<p><strong>描述方式</strong>：状态转移图、状态转移列表、HDL语言描述</p>
<p><strong>常见分类：</strong></p>
<ul>
<li>
<p>摩尔型状态机，输出仅依赖于当前状态，而与输入条件无关</p>
</li>
<li>
<p>米勒型状态机，输出不仅依赖于当前状态，而且取决于该状态的输入条件</p>
</li>
<li>
<p>根据状态机的数量是否为有限个，可分为有限状态机（Finite State Machine，FSM）和无限型状态机（Infinite State Machine，ISM）</p>
</li>
</ul>
<h2 id="如何写好状态机"><a class="header-anchor" href="#如何写好状态机"></a>如何写好状态机</h2>
<hr>
<p><strong>好的RTL级FSM描述具备以下特点：</strong></p>
<ul>
<li>FSM要安全，稳定性高；</li>
<li>FSM速度快，满足设计的频率要求；</li>
<li>FSM面积小，满足设计的面积要求；</li>
<li>FSM要清晰易懂、易于维护</li>
</ul>
<p>即在FSM中需要注意完备性，综合的结果无毛刺等异常扰动，在满足时序要求的前提下，占用最小的面积，或者在满足面积要求的情况下，是设计的时序余量更大，频率更高。</p>
<h3 id="一段式状态机"><a class="header-anchor" href="#一段式状态机"></a>一段式状态机</h3>
<p>应该避免的写法。</p>
<p>设计的整个状态机写到1各always模块中，在该模块既描述状态转移，又描述状态的输入输出，这种写法称为一段式。</p>
<p><img src="https://i.loli.net/2020/04/06/TS157YB9PUbVReH.jpg" alt="状态机1.png"></p>
<p>主要缺点：</p>
<ul>
<li>状态转移判断的组合逻辑和状态寄存器转移的时序逻辑混写在同一always模块中，不符合时序和组合逻辑分开描述的coding style；</li>
<li>代码结构不清晰，不利于维护，且不利于附加约束，不利于综合器和布局布线对设计的优化；</li>
<li>另外该描述方法冗长，一般来说，一段式代码长度会比两段式长大约80%~150%。</li>
</ul>
<h3 id="两段式状态机"><a class="header-anchor" href="#两段式状态机"></a>两段式状态机</h3>
<p>推荐的FSM描述方法之一。</p>
<p>实现方法，一个always模块采用同步时序描述状态转移；另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律。</p>
<p><img src="https://i.loli.net/2020/04/06/XkpzN794gVUMJ5I.jpg" alt="状态机2.jpg"></p>
<p>缺点：输出一般使用组合逻辑描述，容易产生毛刺等不稳定因素。</p>
<h3 id="三段式状态机"><a class="header-anchor" href="#三段式状态机"></a>三段式状态机</h3>
<p>比较推荐的写法。</p>
<p>关键在于使用同步时序逻辑寄存FSM的输出。</p>
<p>两段式状态机根据CS 决定输出结果，而三段式状态机根据NS 决定输出结果</p>
<p><img src="https://i.loli.net/2020/04/06/mca4zjGpi8gsAnK.png" alt="状态机3.png"></p>
<p>优势：</p>
<ul>
<li>
<p>使FSM做到了同步逻辑；</p>
</li>
<li>
<p>消除了组合逻辑输出的不稳定与毛刺的隐患；</p>
</li>
<li>
<p>更利于时序路径分组；</p>
</li>
<li>
<p>在FPGA/CPLD等可编程逻辑器件上的综合与布局布线效果更佳</p>
</li>
</ul>
<h2 id="RTL"><a class="header-anchor" href="#RTL"></a>RTL</h2>
<h3 id="两段式状态机-v2"><a class="header-anchor" href="#两段式状态机-v2"></a>两段式状态机</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Add a default state to make it more safe</span></span><br><span class="line"><span class="keyword">module</span> state2_default ( nrst,clk,</span><br><span class="line">                i1,i2,</span><br><span class="line">                o1,o2,</span><br><span class="line">                err</span><br><span class="line">               );</span><br><span class="line">         </span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS,CS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]      <span class="comment">//one hot with zero idle</span></span><br><span class="line">      IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">      S1     = <span class="number">3'b001</span>,</span><br><span class="line">      S2     = <span class="number">3'b010</span>,</span><br><span class="line">      ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">      <span class="keyword">if</span> (!nrst)            </span><br><span class="line">         CS &lt;= IDLE;        </span><br><span class="line">      <span class="keyword">else</span>                  </span><br><span class="line">         CS &lt;=NS;           </span><br><span class="line"></span><br><span class="line"><span class="comment">//combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @ (nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2)</span><br><span class="line">          <span class="keyword">begin</span></span><br><span class="line">               NS = <span class="number">3'bx</span>;</span><br><span class="line">               ERROR_out;</span><br><span class="line">               <span class="keyword">case</span> (CS)</span><br><span class="line">                    IDLE: <span class="keyword">begin</span></span><br><span class="line">                        IDLE_out;</span><br><span class="line">                        <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                        <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                        <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    S1: <span class="keyword">begin</span></span><br><span class="line">                        S1_out;</span><br><span class="line">                        <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                        <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                        <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    S2: <span class="keyword">begin</span></span><br><span class="line">                         S2_out;</span><br><span class="line">                         <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">			           	 <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                         <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    ERROR: <span class="keyword">begin</span></span><br><span class="line">                    	  ERROR_out;</span><br><span class="line">                          <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                          <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>:  <span class="keyword">begin</span></span><br><span class="line">                    	  IDLE_out;</span><br><span class="line">                          NS = IDLE;</span><br><span class="line">                    <span class="keyword">end</span> </span><br><span class="line">               <span class="keyword">endcase</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//output task</span></span><br><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">     &#123;o1,o2,err&#125; = <span class="number">3'b000</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> S1_out;</span><br><span class="line">     &#123;o1,o2,err&#125; = <span class="number">3'b100</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> S2_out;</span><br><span class="line">     &#123;o1,o2,err&#125; = <span class="number">3'b010</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> ERROR_out;</span><br><span class="line">     &#123;o1,o2,err&#125; = <span class="number">3'b111</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="三段式状态机-v2"><a class="header-anchor" href="#三段式状态机-v2"></a>三段式状态机</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">//Describe sequential state transition in the 1st sequential always block</span></span><br><span class="line"><span class="comment">//State transition conditions in the 2nd combinational always block</span></span><br><span class="line"><span class="comment">//Describe the FSM out in the 3rd sequential always block</span></span><br><span class="line"><span class="comment">//Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">//Verilog Usage Book</span></span><br><span class="line"><span class="keyword">module</span> state3 ( nrst,clk,</span><br><span class="line">                i1,i2,</span><br><span class="line">                o1,o2,</span><br><span class="line">                err</span><br><span class="line">               );</span><br><span class="line">         </span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS,CS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]      <span class="comment">//one hot with zero idle</span></span><br><span class="line">      IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">      S1     = <span class="number">3'b001</span>,</span><br><span class="line">      S2     = <span class="number">3'b010</span>,</span><br><span class="line">      ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1st always block, sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">      <span class="keyword">if</span> (!nrst)            </span><br><span class="line">         CS &lt;= IDLE;        </span><br><span class="line">      <span class="keyword">else</span>                  </span><br><span class="line">         CS &lt;=NS;           </span><br><span class="line"></span><br><span class="line"><span class="comment">//2nd always block, combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @ (nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2)</span><br><span class="line">          <span class="keyword">begin</span></span><br><span class="line">               NS = <span class="number">3'bx</span>;</span><br><span class="line">               <span class="keyword">case</span> (CS)</span><br><span class="line">                    IDLE:     <span class="keyword">begin</span></span><br><span class="line">                                   <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                                   <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                                   <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                              <span class="keyword">end</span></span><br><span class="line">                    S1:       <span class="keyword">begin</span></span><br><span class="line">                                   <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                                   <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                                   <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                              <span class="keyword">end</span></span><br><span class="line">                    S2:       <span class="keyword">begin</span></span><br><span class="line">                                   <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">			           <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                                   <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                              <span class="keyword">end</span></span><br><span class="line">                    ERROR:    <span class="keyword">begin</span></span><br><span class="line">                                   <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                                   <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                              <span class="keyword">end</span></span><br><span class="line">               <span class="keyword">endcase</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3rd always block, the sequential FSM output</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line"> <span class="keyword">if</span> (!nrst)</span><br><span class="line">      &#123;o1,o2,err&#125; &lt;= <span class="number">3'b000</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">       &#123;o1,o2,err&#125; &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">       <span class="keyword">case</span> (NS)</span><br><span class="line">           IDLE:  &#123;o1,o2,err&#125;&lt;=<span class="number">3'b000</span>;</span><br><span class="line"></span><br><span class="line">           S1:    &#123;o1,o2,err&#125;&lt;=<span class="number">3'b100</span>;</span><br><span class="line">           S2:    &#123;o1,o2,err&#125;&lt;=<span class="number">3'b010</span>;</span><br><span class="line">           ERROR: &#123;o1,o2,err&#125;&lt;=<span class="number">3'b111</span>; </span><br><span class="line">       <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>Reference</em>：</p>
<p>1.轻松成为设计高手–Verilog HDL 实用精讲</p>
]]></content>
      <categories>
        <category>数字IC设计基础</category>
      </categories>
      <tags>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>复位电路</title>
    <url>/2020/%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>异步复位，同步释放从何而来？</p>
<a id="more"></a>
<h2 id="复位电路"><a class="header-anchor" href="#复位电路"></a>复位电路</h2>
<hr>
<p>时序电路是双稳态电路，必须有复位信号。组合逻辑电路，没有存储功能，不需要复位信号。</p>
<p>复位电路实现两个方面的功能：</p>
<ul>
<li>仿真的时候使电路进入初始状态或者其他预知状态；</li>
<li>对于综合实现的真实电路，通过复位使电路进入初始状态或者其他预知状态。</li>
</ul>
<h2 id="同步复位电路"><a class="header-anchor" href="#同步复位电路"></a>同步复位电路</h2>
<hr>
<p>当复位信号发生变化时，并不立即生效，只有当有效时钟沿采样到已变化的复位信号后，才对所有寄存器复位。</p>
<p><strong>优点</strong></p>
<ul>
<li>有利于仿真器的仿真；</li>
<li>可以使所设计的系统成为100%的同步时序电路，利于时序分析，综合出来的频率一般比较高；</li>
<li>只在时钟有效电平到来时才复位，可以滤除高于时钟频率的毛刺。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>复位信号的有效时长必须大于时钟周期，才能真正被系统识别并完成复位任务。同时还要考虑，诸如：clk_skew,组合逻辑延时，复位延时等因素；</li>
</ul>
<blockquote>
<p><code>Tsyn_rst &gt; Period max + (clk2-clk1) + t1 + t2</code></p>
</blockquote>
<ul>
<li>由于大多数的逻辑器件的目标库内的DFF都只有异步复位端口，所以，倘若采用同步复位的话，综合器就会在寄存器的数据输入端口插入组合逻辑，这样就会浪费较多的逻辑资源。</li>
</ul>
<p><img src="https://i.loli.net/2020/04/04/ybnQio1tuJM9acX.png" alt="复位电路1.png"></p>
<h2 id="异步复位"><a class="header-anchor" href="#异步复位"></a>异步复位</h2>
<hr>
<p>当复位信号到达时，无论时钟触发沿是否有效，都会立即对目标（如寄存器、RAM等）复位。</p>
<p><strong>优点</strong></p>
<ul>
<li>大多数目标器件库的dff都有异步复位端口，采用异步复位可以节省资源；</li>
<li>设计相对简单；</li>
<li>异步复位信号识别方便，而且可以很方便的使用FPGA的全局复位端口(GSR,Global Set Reset)。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>在复位信号释放时容易出现问题。例如，复位释放时恰恰在时钟有效沿附近，就容易是寄存器输出出现亚稳态，从而导致亚稳态；</li>
<li>复位信号容易受到毛刺的影响</li>
</ul>
<p><img src="https://i.loli.net/2020/04/04/7SDNGq2fEavyzgM.png" alt="复位电路2.png"></p>
<h2 id="异步复位，同步释放"><a class="header-anchor" href="#异步复位，同步释放"></a>异步复位，同步释放</h2>
<hr>
<p>异步复位：复位信号在任意时刻到达低电平及复位，不需要和时钟同步</p>
<p>同步释放：复位信号取消的时候，必须跟时钟信号同步</p>
<p><strong>优点</strong></p>
<ul>
<li>只要复位信号有效，电路就处于复位状态；</li>
<li>短脉宽复位也不会丢失；</li>
<li>复位的撤离是同步信号，有良好的的撤离时序和足够的恢复时间。</li>
</ul>
<p><img src="https://i.loli.net/2020/04/04/VwupLPBm18OFHU4.png" alt="复位电路3.png"></p>
<h2 id="RTL"><a class="header-anchor" href="#RTL"></a>RTL</h2>
<hr>
<h3 id="syn-rst"><a class="header-anchor" href="#syn-rst"></a>syn_rst</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> syn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">   <span class="keyword">if</span> (!rst_)</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2'b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="asyn-rst"><a class="header-anchor" href="#asyn-rst"></a>asyn_rst</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> asyn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_)</span><br><span class="line">   <span class="keyword">if</span> (!rst_)</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2'b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="asyn-rst，syn-release"><a class="header-anchor" href="#asyn-rst，syn-release"></a>asyn_rst，syn_release</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> asyn_rst_syn_release(clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset release circuit</span></span><br><span class="line"><span class="keyword">reg</span> reset_reg;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">     reset_reg &lt;= rst_;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_reg)</span><br><span class="line">   <span class="keyword">if</span> (!rst_)</span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2'b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>Reference</em>：</p>
<p>1.轻松成为设计高手–Verilog HDL 实用精讲</p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <categories>
        <category>数字IC设计基础</category>
      </categories>
      <tags>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>FIFO 介绍2</title>
    <url>/2020/FIFO-%E4%BB%8B%E7%BB%8D2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如何对FIFO最小深度计算和FIFO空满标志判断的漏洞分析。</p>
<a id="more"></a>
<h2 id="FIFO-深度计算"><a class="header-anchor" href="#FIFO-深度计算"></a>FIFO 深度计算</h2>
<hr>
<h3 id="例题分析"><a class="header-anchor" href="#例题分析"></a>例题分析</h3>
<p>例题：假设FIFO的写时钟为100MHZ，读时钟为80MHZ。在FIFO输入侧，每100个写时钟，写入80个数据；读数据侧，假定每个时钟读走一个数据。</p>
<p><em>请问FIFO深度设置为多少可以保证FIFO不会上溢出和下溢出？</em></p>
<p><strong>分析清楚数据轻载和重载时数据的传输任务</strong></p>
<p><img src="https://i.loli.net/2020/03/26/4XNaLU5bHIoDgn3.png" alt="FIFO4.1.png"></p>
<p>如图所示，列出了100个写时钟周期中数据，写入的不同情况。</p>
<p>当第一次100个写时钟内，数据的写入发生在后80个时钟中，且第二次100个时钟内，数据的写入发生在前80个时钟。这种情况下，会有连续的160个时钟周期在写入数据，负荷最重，即是需要分析的重载情况。</p>
<p><strong>分析：</strong></p>
<p>假设写入时为最坏情况（背靠背），即在160*（1/100）微秒内写入160个数据。</p>
<p>写入所需要的时间是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time:burst_cycle * t_wclk &#x3D; burst_cycle&#x2F;f_wclk &#x3D; 160&#x2F;100</span><br></pre></td></tr></table></figure>
<p>该时间段内能读出的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_num_read &#x3D; Time&#x2F;t_read &#x3D; Time&#x2F;(1&#x2F;f_read) &#x3D; Time * f_read &#x3D; (160&#x2F;100) * 80</span><br></pre></td></tr></table></figure>
<p>FIFO应该设置的深度值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depth &#x3D; burst - data_num_read &#x3D; 160 - (160&#x2F;100) * 80 &#x3D; 32</span><br></pre></td></tr></table></figure>
<h3 id="问题一般化"><a class="header-anchor" href="#问题一般化"></a>问题一般化</h3>
<p>参数为：</p>
<ul>
<li>写时钟频率：WCLK；</li>
<li>读时钟频率：RCLK；</li>
<li>写数据时，每B个时钟周期内会有A个数据写入FIFO；</li>
<li>读数据时，每Y个时钟周期内会有X个数据读出FIFO。</li>
</ul>
<p>FIFO的最小深度应为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">depth &#x3D; burst_length - burst_length&#x2F;wclk * (rclk * (X&#x2F;Y))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>burst_length / WCLK 表示burst持续时间；</p>
<p>RCLK *（X/Y）表示读的实际速度，两者乘积为读数据量；</p>
<p>burst_length 表示写入数据量。</p>
</blockquote>
<h2 id="FIFO空满标志的判断方法是否存在漏洞？"><a class="header-anchor" href="#FIFO空满标志的判断方法是否存在漏洞？"></a>FIFO空满标志的判断方法是否存在漏洞？</h2>
<hr>
<p>判断方法回顾：</p>
<ul>
<li>rptr同步到wclk时钟域后，在wclk时钟域与wprt进行比较，生成FULL标志；</li>
<li>wptr同步到rclk时钟域后，在rclk时钟域与rprt进行比较，生成EMPTY标志。</li>
</ul>
<p>假设读写时钟的频率接近，如下图所示。</p>
<p><img src="https://i.loli.net/2020/03/26/1y2pAFSzTu4HfkQ.png" alt="FIFO4.2.png"></p>
<p>判断满状态时，假设将读指针rptr 数据“3”通过电平同步器同步至写时钟域。经过两个wclk时钟周期后，数据到达写时钟域，经wptr比较后相等生成FULL信号。<strong>即在该时刻，FIFO认为已满，且满时的读指针为“3”。实际上，该时刻读指针已经为“5”，FIFO并不是真的满状态。</strong></p>
<p><strong>结论：</strong></p>
<ul>
<li>
<p>对于FULL信号的生成机制，同步后的读地址一定是小于或者等于当前的读地址，所以此时判断FIFO为满不一定为真满，更保守；</p>
</li>
<li>
<p>对于EMPTY信号的生成机制，同样成立，判断为空时不一定为真的空状态；</p>
</li>
<li>
<p>异步FIFO通过比较读写地址来进行空满判断，读写地址的同步机制使得FIFO的空满状态仍然留有余量，存在一定的冗余空间。</p>
</li>
</ul>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://www.sliu.info/2020/FIFO-%E4%BB%8B%E7%BB%8D1/">FIFO 介绍1</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
<p>3.<a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf" target="_blank" rel="noopener">Simulation and Synthesis Techniques for Asynchronous FIFO Design</a></p>
]]></content>
      <categories>
        <category>数字IC设计基础</category>
      </categories>
      <tags>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>FIFO 介绍1</title>
    <url>/2020/FIFO-%E4%BB%8B%E7%BB%8D1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>FIFO的基本介绍，包括同步FIFO、异步FIFO、异步FIFO中常使用的格雷码（Gray code）计数器等</p>
<a id="more"></a>
<h2 id="FIFO常见参数"><a class="header-anchor" href="#FIFO常见参数"></a>FIFO常见参数</h2>
<hr>
<p>FIFO的宽度：即FIFO一次读写操作的数据位；</p>
<p>FIFO的深度：FIFO可以存储多少个N位的数据（如果宽度为N）；</p>
<p>满标志：FIFO已满或将要满时由FIFO的状态电路送出的一个信号，已阻止FIFO的写操作继续向FIFO中写数据而造成溢出（overflow）；</p>
<p>空标志：FIFO已空或将要空时由FIFO的状态电路送出的一个信号，以阻止FIFO的读操作继续从FIFO中读出数据而造成无效数据的读出（underflow）；</p>
<p>读时钟：读操作所遵循的时钟，在每个时钟沿来临时读数据；</p>
<p>写时钟：写操作所遵循的时钟，在每个时钟沿来临写数据。</p>
<h2 id="FIFO-pointers"><a class="header-anchor" href="#FIFO-pointers"></a>FIFO pointers</h2>
<hr>
<p>正确的产生空满标志是任何FIFO设计的关键。<strong>空满标志产生的原则是：写满而不溢出，能读空而不多读。</strong></p>
<p><strong>空满状态的判断</strong></p>
<p>当读写指针相等时，表明FIFO为空，这种情况发生在：</p>
<ul>
<li>复位操作时</li>
<li>读指针读出FIFO中最后一个字后，追赶上了写指针</li>
</ul>
<p>当读写指针再次相等时，表明FIFO为满，这种情况发生在：</p>
<ul>
<li>写指针转了一圈，折回来又追上了读指针</li>
</ul>
<h3 id="同步FIFO指针-Synchronous-FIFO-pointers-："><a class="header-anchor" href="#同步FIFO指针-Synchronous-FIFO-pointers-："></a>同步FIFO指针(Synchronous FIFO pointers)：</h3>
<p>同步FIFO中，在同一时钟域内进行FIFO缓冲区的读写操作。对FIFO缓冲区的写入和读取次数进行计数。</p>
<ul>
<li>
<p>increment：FIFO write but no read；</p>
</li>
<li>
<p>decrement：FIFO read but no write;</p>
</li>
<li>
<p>hold: no writes and reads,or simultaneous write and read operation</p>
</li>
</ul>
<p>直接根据计数器数值来判断空满状态，当计数器达到预设的满值，FIFO填满。当计数器为0时，FIFO为空。</p>
<h3 id="异步FIFO指针-Asynchronous-FIFO-pointers-："><a class="header-anchor" href="#异步FIFO指针-Asynchronous-FIFO-pointers-："></a>异步FIFO指针(Asynchronous FIFO pointers)：</h3>
<p>异步FIFO设计中，则不能简单地增减FIFO填充指针，因为需要使用两个不同的异步时钟来控制计数器。因此，为了确定异步FIFO设计的满状态和空状态，必须比较写指针和读指针。</p>
<p>**当读指针等于写指针时，FIFO为空。**该情况发生在所有指针复位期间复位为0时，或者当读指针赶上写指针，读到FIFO最后一个字节的情况下。</p>
<p><strong>当指针再次相等，即写指针循环一次后再次追赶上读指针，FIFO为满。</strong></p>
<p>为了区分满空状态，我们可以为每个指针添加一个额外的位MSB。写指针增加到FIFO最后一个地址后，将未使用的MSB递增，同时将其余位设置为0，如下图所示。读指针也是如此。</p>
<p><strong>如果两个指针的MSB不同，则意味着写指针比读指针多循环了一次。如果两个指针的MSB相同，则意味着两个指针的换行次数相同。</strong></p>
<p><img src="https://i.loli.net/2020/03/26/WJ5OszSy1GmMtYn.png" alt="FIFO3.2.png"></p>
<h2 id="FIFO结构实例："><a class="header-anchor" href="#FIFO结构实例："></a>FIFO结构实例：</h2>
<hr>
<p>下图为典型的FIFO结构实例，主要包括：</p>
<p>FIFO memory：存储缓存区，可由写入和读取时钟域访问。Memory buffer大多由synchronous dual-port RAM或其它memory 例化而来；</p>
<p>sync_r2w&amp;sync_w2r:同步器电路，用于将读指针同步到写时钟域或将写指针同步到读时钟域中。wptr_full使用同步的读指针来生成满条件；rptr_empty使用同步的写指针来生成FIFO空条件；</p>
<p>rptr_empty：与读时钟域完全同步，并包含了FIFO读指针和空标志逻辑；</p>
<p>wptr_full:与写时钟域完全同步，并包含了FIFO写指针和满标志逻辑。</p>
<p><img src="https://i.loli.net/2020/03/26/ynJBlsjCx6UTmv2.png" alt="FIFO3.1.png"></p>
<p>为了实现FIFO full、empty的判断，读写指针需要传递到对方时钟域中进行比较。为了保证安全的传输到对方时钟域，后面会介绍同步格雷码指针的方法，保证一次只更改一个指针位。</p>
<h2 id="使用格雷码（Gray-Code）计数器"><a class="header-anchor" href="#使用格雷码（Gray-Code）计数器"></a>使用格雷码（Gray Code）计数器</h2>
<hr>
<h3 id="格雷码的特点："><a class="header-anchor" href="#格雷码的特点："></a>格雷码的特点：</h3>
<ul>
<li>相邻的2个数值之间只会有1位发生变化，其余各位相同；</li>
<li>是一种循环码，0和最大数（2的n次方减1）之间也只有一位不同</li>
</ul>
<h3 id="Gray-To-Binary-Conversion"><a class="header-anchor" href="#Gray-To-Binary-Conversion"></a>Gray To Binary Conversion</h3>
<p>4 bit Gray To Binary Conversion:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">bin[<span class="number">0</span>]= gray[<span class="number">3</span>] ^ gray[<span class="number">2</span>] ^ gray[<span class="number">1</span>] ^ gray[<span class="number">0</span>];</span><br><span class="line">bin[<span class="number">1</span>] = gray[<span class="number">3</span>] ^ gray[<span class="number">2</span>] ^ gray[<span class="number">1</span>];</span><br><span class="line">bin[<span class="number">2</span>] = gray[<span class="number">3</span>] ^ gray[<span class="number">2</span>];</span><br><span class="line">bin[<span class="number">3</span>] = gray[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>verilog 实现，通过采用填充0 的方式对有效的格雷码位进行异或操作，如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">bin[<span class="number">0</span>] = gray[<span class="number">3</span>] ^ gray[<span class="number">2</span>] ^ gray[<span class="number">1</span>] ^ gray[<span class="number">0</span>] ; <span class="comment">// gray&gt;&gt;0</span></span><br><span class="line">bin[<span class="number">1</span>] =   <span class="number">1'b0</span>  ^ gray[<span class="number">3</span>] ^ gray[<span class="number">2</span>] ^ gray[<span class="number">1</span>] ; <span class="comment">// gray&gt;&gt;1</span></span><br><span class="line">bin[<span class="number">2</span>] =   <span class="number">1'b0</span>  ^   <span class="number">1'b0</span>  ^ gray[<span class="number">3</span>] ^ gray[<span class="number">2</span>] ; <span class="comment">// gray&gt;&gt;2</span></span><br><span class="line">bin[<span class="number">3</span>] =   <span class="number">1'b0</span>  ^   <span class="number">1'b0</span>  ^   <span class="number">1'b0</span>  ^ gray[<span class="number">3</span>] ; <span class="comment">// gray&gt;&gt;3</span></span><br></pre></td></tr></table></figure>
<p>Code:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> gray2bin (bin, gray);</span><br><span class="line">  <span class="keyword">parameter</span> SIZE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">output</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] bin;</span><br><span class="line">  <span class="keyword">input</span>  [SIZE-<span class="number">1</span>:<span class="number">0</span>] gray;</span><br><span class="line">  <span class="keyword">reg</span>    [SIZE-<span class="number">1</span>:<span class="number">0</span>] bin;</span><br><span class="line">  <span class="keyword">integer</span>           i;</span><br><span class="line">  <span class="keyword">always</span> @(gray)</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;SIZE; i=i+<span class="number">1</span>)</span><br><span class="line">      bin[i] = ^(gray&gt;&gt;i);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Binary-To-Gray-Conversion"><a class="header-anchor" href="#Binary-To-Gray-Conversion"></a>Binary To Gray Conversion</h3>
<p>4bit binary-to-gray conversion:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">gray[<span class="number">0</span>] = bin[<span class="number">0</span>] ^ bin[<span class="number">1</span>];</span><br><span class="line">gray[<span class="number">1</span>] = bin[<span class="number">1</span>] ^ bin[<span class="number">2</span>];</span><br><span class="line">gray[<span class="number">2</span>] = bin[<span class="number">2</span>] ^ bin[<span class="number">3</span>];</span><br><span class="line">gray[<span class="number">3</span>] = bin[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>Code:</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bin2gray (gray, bin);</span><br><span class="line">  <span class="keyword">parameter</span> SIZE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">output</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] gray;</span><br><span class="line">  <span class="keyword">input</span>  [SIZE-<span class="number">1</span>:<span class="number">0</span>] bin;</span><br><span class="line">  <span class="keyword">assign</span> gray = (bin&gt;&gt;<span class="number">1</span>) ^ bin;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Gray-Code-Counter"><a class="header-anchor" href="#Gray-Code-Counter"></a>Gray Code Counter</h3>
<p>verilog Code中包含一个gray-to-binary 和一个binary-to-gray转换器，并在两者之间递增1。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> graycntr (gray, clk, inc, rst_n);</span><br><span class="line">  <span class="keyword">parameter</span> SIZE = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">output</span> [SIZE-<span class="number">1</span>:<span class="number">0</span>] gray;</span><br><span class="line">  <span class="keyword">input</span>             clk, inc, rst_n;</span><br><span class="line">  <span class="keyword">reg</span>    [SIZE-<span class="number">1</span>:<span class="number">0</span>] gnext, gray, bnext, bin;</span><br><span class="line">  <span class="keyword">integer</span>           i;</span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rst_n) gray &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>        gray &lt;= gnext;</span><br><span class="line">  <span class="keyword">always</span> @(gray <span class="keyword">or</span> inc) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;SIZE; i=i+<span class="number">1</span>)</span><br><span class="line">      bin[i] = ^(gray&gt;&gt;i);</span><br><span class="line">    bnext = bin + inc;</span><br><span class="line">    gnext = (bnext&gt;&gt;<span class="number">1</span>) ^ bnext;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>Gray-code counter block diagram：</p>
<p><img src="https://i.loli.net/2020/03/26/yisngNOo1lAqkTu.png" alt="FIFO3.3.png"></p>
<h2 id="使用Gray-Code后，如何做空满判断？"><a class="header-anchor" href="#使用Gray-Code后，如何做空满判断？"></a>使用Gray Code后，如何做空满判断？</h2>
<hr>
<p>空状态：依据二者完全相等（包括MSB）</p>
<p>满状态：由于gray码除了MSB外，具有镜像对称的特点，存在一个特殊情况。当读指针指向7，写指针指向8时，除了MSB，其余位皆相同，不能算满。</p>
<p><img src="https://i.loli.net/2020/03/26/ew4r8F5H6muf9Pp.png" alt="FIFO3.4.png"></p>
<p>未解决上述出现的问题，特地改进Gray code counter，如下图所示,采用一种dual n-bit Gray code counter。</p>
<p><em>n-bit Gray code converted to an (n-1)-bit Gray code</em></p>
<p><img src="https://i.loli.net/2020/03/26/br8mwJD6tAKVTN5.png" alt="FIFO3.5.png"></p>
<p><em>Dual n-bit Gray code counter block diagram</em></p>
<p><img src="https://i.loli.net/2020/03/26/tAyQmYOBGlVFg9b.png" alt="FIFO3.6.png"></p>
<p>使用Grey判断须同时满足以下3条：</p>
<ul>
<li>wptr和同步过来的rptr的<strong>MSB不相等</strong>；</li>
<li>wptr与rptr的<strong>次高位不相等</strong>，如上图位置7和位置15，转化为二进制对应的是0111和1111，MSB不同说明多折回一次，111相同代表同一位置；</li>
<li><strong>剩下的其余位完全相等</strong>。</li>
</ul>
<h2 id="RTL-code-for-FIFO"><a class="header-anchor" href="#RTL-code-for-FIFO"></a>RTL code for FIFO</h2>
<hr>
<h3 id="fifo-v-FIFO-top-level-module"><a class="header-anchor" href="#fifo-v-FIFO-top-level-module"></a>fifo.v-FIFO top-level module</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fifo1 #(<span class="keyword">parameter</span> DSIZE = <span class="number">8</span>,</span><br><span class="line">               <span class="keyword">parameter</span> ASIZE = <span class="number">4</span>)</span><br><span class="line">  (<span class="keyword">output</span> [DSIZE-<span class="number">1</span>:<span class="number">0</span>] rdata,</span><br><span class="line">   <span class="keyword">output</span>             wfull,</span><br><span class="line">   <span class="keyword">output</span>             rempty,</span><br><span class="line">   <span class="keyword">input</span>  [DSIZE-<span class="number">1</span>:<span class="number">0</span>] wdata,</span><br><span class="line">   <span class="keyword">input</span>              winc, wclk, wrst_n,</span><br><span class="line">   <span class="keyword">input</span>              rinc, rclk, rrst_n);</span><br><span class="line">  <span class="keyword">wire</span>   [ASIZE-<span class="number">1</span>:<span class="number">0</span>] waddr, raddr;</span><br><span class="line">  <span class="keyword">wire</span>   [ASIZE:<span class="number">0</span>]   wptr, rptr, wq2_rptr, rq2_wptr;</span><br><span class="line">  sync_r2w      sync_r2w  (<span class="variable">.wq2_rptr</span>(wq2_rptr), <span class="variable">.rptr</span>(rptr),</span><br><span class="line">                           <span class="variable">.wclk</span>(wclk), <span class="variable">.wrst_n</span>(wrst_n));</span><br><span class="line">  sync_w2r      sync_w2r  (<span class="variable">.rq2_wptr</span>(rq2_wptr), <span class="variable">.wptr</span>(wptr),</span><br><span class="line">                           <span class="variable">.rclk</span>(rclk), <span class="variable">.rrst_n</span>(rrst_n));</span><br><span class="line">  fifomem <span class="variable">#(DSIZE, ASIZE)</span> fifomem</span><br><span class="line">                          (<span class="variable">.rdata</span>(rdata), <span class="variable">.wdata</span>(wdata),</span><br><span class="line">                           <span class="variable">.waddr</span>(waddr), <span class="variable">.raddr</span>(raddr),</span><br><span class="line">                           <span class="variable">.wclken</span>(winc), <span class="variable">.wfull</span>(wfull),</span><br><span class="line">                           <span class="variable">.wclk</span>(wclk));</span><br><span class="line">  rptr_empty <span class="variable">#(ASIZE)</span>     rptr_empty</span><br><span class="line">                          (<span class="variable">.rempty</span>(rempty),</span><br><span class="line">                           <span class="variable">.raddr</span>(raddr),</span><br><span class="line">                           <span class="variable">.rptr</span>(rptr), <span class="variable">.rq2_wptr</span>(rq2_wptr),</span><br><span class="line">                           <span class="variable">.rinc</span>(rinc), <span class="variable">.rclk</span>(rclk),</span><br><span class="line">                           <span class="variable">.rrst_n</span>(rrst_n));</span><br><span class="line">  wptr_full  <span class="variable">#(ASIZE)</span>     wptr_full</span><br><span class="line">                          (<span class="variable">.wfull</span>(wfull), <span class="variable">.waddr</span>(waddr),</span><br><span class="line">                           <span class="variable">.wptr</span>(wptr), <span class="variable">.wq2_rptr</span>(wq2_rptr),</span><br><span class="line">                           <span class="variable">.winc</span>(winc), <span class="variable">.wclk</span>(wclk),</span><br><span class="line">                           <span class="variable">.wrst_n</span>(wrst_n));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="fifomem-v-FIFO-memory-buffer"><a class="header-anchor" href="#fifomem-v-FIFO-memory-buffer"></a>fifomem.v - FIFO memory buffer</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> fifomem #(<span class="keyword">parameter</span>  DATASIZE = <span class="number">8</span>, <span class="comment">// Memory data word width</span></span><br><span class="line">                 <span class="keyword">parameter</span>  ADDRSIZE = <span class="number">4</span>) <span class="comment">// Number of mem address bits</span></span><br><span class="line">  (<span class="keyword">output</span> [DATASIZE-<span class="number">1</span>:<span class="number">0</span>] rdata,</span><br><span class="line">   <span class="keyword">input</span>  [DATASIZE-<span class="number">1</span>:<span class="number">0</span>] wdata,</span><br><span class="line">   <span class="keyword">input</span>  [ADDRSIZE-<span class="number">1</span>:<span class="number">0</span>] waddr, raddr,</span><br><span class="line">   <span class="keyword">input</span>                 wclken, wfull, wclk);</span><br><span class="line">  ìfdef VENDORRAM</span><br><span class="line">    <span class="comment">// instantiation of a vendor's dual-port RAM</span></span><br><span class="line">    vendor_ram mem (<span class="variable">.dout</span>(rdata), <span class="variable">.din</span>(wdata),</span><br><span class="line">                    <span class="variable">.waddr</span>(waddr), <span class="variable">.raddr</span>(raddr),</span><br><span class="line">                    <span class="variable">.wclken</span>(wclken),</span><br><span class="line">                    <span class="variable">.wclken_n</span>(wfull), <span class="variable">.clk</span>(wclk));</span><br><span class="line">  èlse</span><br><span class="line">    <span class="comment">// RTL Verilog memory model</span></span><br><span class="line">    <span class="keyword">localparam</span> DEPTH = <span class="number">1</span>&lt;&lt;ADDRSIZE;</span><br><span class="line">    <span class="keyword">reg</span> [DATASIZE-<span class="number">1</span>:<span class="number">0</span>] mem [<span class="number">0</span>:DEPTH-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> rdata = mem[raddr];</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk)</span><br><span class="line">      <span class="keyword">if</span> (wclken &amp;&amp; !wfull) mem[waddr] &lt;= wdata;</span><br><span class="line">  èndif</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="sync-r2w-v-Read-domain-to-write-domain-synchronizer"><a class="header-anchor" href="#sync-r2w-v-Read-domain-to-write-domain-synchronizer"></a>sync_r2w.v - Read-domain to write-domain synchronizer</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sync_r2w #(<span class="keyword">parameter</span> ADDRSIZE = <span class="number">4</span>)</span><br><span class="line">  (<span class="keyword">output</span> <span class="keyword">reg</span> [ADDRSIZE:<span class="number">0</span>] wq2_rptr,</span><br><span class="line">   <span class="keyword">input</span>      [ADDRSIZE:<span class="number">0</span>] rptr,</span><br><span class="line">   <span class="keyword">input</span>                   wclk, wrst_n);</span><br><span class="line">  <span class="keyword">reg</span> [ADDRSIZE:<span class="number">0</span>] wq1_rptr;</span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk <span class="keyword">or</span> <span class="keyword">negedge</span> wrst_n)</span><br><span class="line">    <span class="keyword">if</span> (!wrst_n) &#123;wq2_rptr,wq1_rptr&#125; &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>         &#123;wq2_rptr,wq1_rptr&#125; &lt;= &#123;wq1_rptr,rptr&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="sync-w2r-v-Write-domain-to-read-domain-synchronizer"><a class="header-anchor" href="#sync-w2r-v-Write-domain-to-read-domain-synchronizer"></a>sync_w2r.v - Write-domain to read-domain synchronizer</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sync_w2r #(<span class="keyword">parameter</span> ADDRSIZE = <span class="number">4</span>)</span><br><span class="line">  (<span class="keyword">output</span> <span class="keyword">reg</span> [ADDRSIZE:<span class="number">0</span>] rq2_wptr,</span><br><span class="line">   <span class="keyword">input</span>      [ADDRSIZE:<span class="number">0</span>] wptr,</span><br><span class="line">   <span class="keyword">input</span>                   rclk, rrst_n);</span><br><span class="line">  <span class="keyword">reg</span> [ADDRSIZE:<span class="number">0</span>] rq1_wptr;</span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk <span class="keyword">or</span> <span class="keyword">negedge</span> rrst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rrst_n) &#123;rq2_wptr,rq1_wptr&#125; &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>         &#123;rq2_wptr,rq1_wptr&#125; &lt;= &#123;rq1_wptr,wptr&#125;;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="rptr-empty-v-Read-pointer-empty-generation-logic"><a class="header-anchor" href="#rptr-empty-v-Read-pointer-empty-generation-logic"></a>rptr_empty.v - Read pointer &amp; empty generation logic</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> rptr_empty #(<span class="keyword">parameter</span> ADDRSIZE = <span class="number">4</span>)</span><br><span class="line">  (<span class="keyword">output</span> <span class="keyword">reg</span>                rempty,</span><br><span class="line">   <span class="keyword">output</span>     [ADDRSIZE-<span class="number">1</span>:<span class="number">0</span>] raddr,</span><br><span class="line">   <span class="keyword">output</span> <span class="keyword">reg</span> [ADDRSIZE  :<span class="number">0</span>] rptr,</span><br><span class="line">   <span class="keyword">input</span>      [ADDRSIZE  :<span class="number">0</span>] rq2_wptr,</span><br><span class="line">   <span class="keyword">input</span>                     rinc, rclk, rrst_n);</span><br><span class="line">  <span class="keyword">reg</span>  [ADDRSIZE:<span class="number">0</span>] rbin;</span><br><span class="line">  <span class="keyword">wire</span> [ADDRSIZE:<span class="number">0</span>] rgraynext, rbinnext;</span><br><span class="line">  <span class="comment">//-------------------</span></span><br><span class="line">  <span class="comment">// GRAYSTYLE2 pointer</span></span><br><span class="line">  <span class="comment">//-------------------</span></span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk <span class="keyword">or</span> <span class="keyword">negedge</span> rrst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rrst_n) &#123;rbin, rptr&#125; &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>         &#123;rbin, rptr&#125; &lt;= &#123;rbinnext, rgraynext&#125;;</span><br><span class="line">  <span class="comment">// Memory read-address pointer (okay to use binary to address memory)</span></span><br><span class="line">  <span class="keyword">assign</span> raddr     = rbin[ADDRSIZE-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> rbinnext  = rbin + (rinc &amp; ~rempty);</span><br><span class="line">  <span class="keyword">assign</span> rgraynext = (rbinnext&gt;&gt;<span class="number">1</span>) ^ rbinnext;</span><br><span class="line">  <span class="comment">//---------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">// FIFO empty when the next rptr == synchronized wptr or on reset</span></span><br><span class="line">  <span class="comment">//---------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">assign</span> rempty_val = (rgraynext == rq2_wptr);</span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> rclk <span class="keyword">or</span> <span class="keyword">negedge</span> rrst_n)</span><br><span class="line">    <span class="keyword">if</span> (!rrst_n) rempty &lt;= <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">else</span>         rempty &lt;= rempty_val;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="wptr-full-v-Write-pointer-full-generation-logic"><a class="header-anchor" href="#wptr-full-v-Write-pointer-full-generation-logic"></a>wptr_full.v - Write pointer &amp; full generation logic</h3>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> wptr_full  #(<span class="keyword">parameter</span> ADDRSIZE = <span class="number">4</span>)</span><br><span class="line">  (<span class="keyword">output</span> <span class="keyword">reg</span>                wfull,</span><br><span class="line">   <span class="keyword">output</span>     [ADDRSIZE-<span class="number">1</span>:<span class="number">0</span>] waddr,</span><br><span class="line">   <span class="keyword">output</span> <span class="keyword">reg</span> [ADDRSIZE  :<span class="number">0</span>] wptr,</span><br><span class="line">   <span class="keyword">input</span>      [ADDRSIZE  :<span class="number">0</span>] wq2_rptr,</span><br><span class="line">   <span class="keyword">input</span>                     winc, wclk, wrst_n);</span><br><span class="line">  <span class="keyword">reg</span>  [ADDRSIZE:<span class="number">0</span>] wbin;</span><br><span class="line">  <span class="keyword">wire</span> [ADDRSIZE:<span class="number">0</span>] wgraynext, wbinnext;</span><br><span class="line">  <span class="comment">// GRAYSTYLE2 pointer</span></span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk <span class="keyword">or</span> <span class="keyword">negedge</span> wrst_n)</span><br><span class="line">    <span class="keyword">if</span> (!wrst_n) &#123;wbin, wptr&#125; &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>         &#123;wbin, wptr&#125; &lt;= &#123;wbinnext, wgraynext&#125;;</span><br><span class="line">  <span class="comment">// Memory write-address pointer (okay to use binary to address memory)</span></span><br><span class="line">  <span class="keyword">assign</span> waddr = wbin[ADDRSIZE-<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">assign</span> wbinnext  = wbin + (winc &amp; ~wfull);</span><br><span class="line">  <span class="keyword">assign</span> wgraynext = (wbinnext&gt;&gt;<span class="number">1</span>) ^ wbinnext;</span><br><span class="line">  <span class="comment">//------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">// Simplified version of the three necessary full-tests:</span></span><br><span class="line">  <span class="comment">// assign wfull_val=((wgnext[ADDRSIZE]    !=wq2_rptr[ADDRSIZE]  ) &amp;&amp;</span></span><br><span class="line">  <span class="comment">//                   (wgnext[ADDRSIZE-1]  !=wq2_rptr[ADDRSIZE-1]) &amp;&amp;</span></span><br><span class="line">  <span class="comment">//                   (wgnext[ADDRSIZE-2:0]==wq2_rptr[ADDRSIZE-2:0]));</span></span><br><span class="line">  <span class="comment">//------------------------------------------------------------------</span></span><br><span class="line">  <span class="keyword">assign</span> wfull_val = (wgraynext==&#123;~wq2_rptr[ADDRSIZE:ADDRSIZE-<span class="number">1</span>],</span><br><span class="line">                                   wq2_rptr[ADDRSIZE-<span class="number">2</span>:<span class="number">0</span>]&#125;);</span><br><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> wclk <span class="keyword">or</span> <span class="keyword">negedge</span> wrst_n)</span><br><span class="line">    <span class="keyword">if</span> (!wrst_n) wfull  &lt;= <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">else</span>         wfull  &lt;= wfull_val;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_FIFO1.pdf" target="_blank" rel="noopener">Simulation and Synthesis Techniques for Asynchronous FIFO Design</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <categories>
        <category>数字IC设计基础</category>
      </categories>
      <tags>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>信号的跨时钟域传输问题</title>
    <url>/2020/%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%B7%A8%E6%97%B6%E9%92%9F%E5%9F%9F%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>快时钟域向慢时钟域过渡时如何采用“结绳法”进行过渡以及多bit指示信号和多bit数据流的跨时钟域处理方法</p>
<a id="more"></a>
<h2 id="结绳法（快时钟–-慢时钟）"><a class="header-anchor" href="#结绳法（快时钟–-慢时钟）"></a>结绳法（快时钟–&gt;慢时钟）</h2>
<hr>
<p>信号从快时钟域到慢时钟域过渡时，慢时钟将可能无法对变化太快的信号实现正确采样，前述同步器对两个时钟之间的关系要求很严格，采用“结绳法”则适合任何时钟的过渡。</p>
<p><strong>原理：</strong></p>
<ul>
<li>将时钟信号的脉冲周期延长，等到慢时钟同步采样后再“解绳”，还原为原来的脉冲周期宽度。</li>
</ul>
<p><strong>结绳法1：</strong></p>
<p>利用数据的边沿作时钟（图中上升沿）。数据作为Din_ClkA，当有数据有上升沿（0–&gt;1）时，寄存器1稳定在高电平。等待CLKB采样，采样后寄存器4输出高电平，若此时Din_ClkA为低电平，即完成复位，开始下一次采样等待。</p>
<p><img src="https://i.loli.net/2020/03/14/ctnbpkZzIdNQPf7.png" alt="跨时钟域2.1.png"></p>
<p><strong>注意：</strong></p>
<p>数据来临时，CLKB需要等待3个周期，最终通过寄存器4反馈数据信息完成复位。如果Din_CLKA变化较快，即持续时间短于3个CLKB，也就是频率大于1/3 CLKB，此时Din_CLKA的变化将无法被采样到，因为CLKB域需要3个CLKB周期才能完成采样，并且此时DIN_CLKA必须是低电平才能复位，采用异步复位。</p>
<p>在慢时钟采样快时钟的时候，结绳法适合采样数据较少（即脉冲间隔较大）的控制信号。即脉冲间隔Ta &gt; 3Tb;即等待3个CLKB时钟后，完成复位，才允许下一个输入脉冲。</p>
<p><strong>结绳法2：</strong></p>
<p>利用数据作为异步复位，置位信号。</p>
<p><img src="https://i.loli.net/2020/03/14/lPrhXa2InBcKo15.png" alt="跨时钟域2.2.png"><img src="https://i.loli.net/2020/03/14/lRY7ZKf19seCdSb.png" alt="跨时钟域2.3.png"></p>
<p><strong>结绳法3：</strong></p>
<p>利用握手协议</p>
<p>下图描述了实现方法，主要包括三个基本单元：Pluse2Toggle, Synchronizer 和Toggle2Pluse：</p>
<ol>
<li>Pluse2Toggle模块负责将两个脉冲信号“结绳”，即将单脉冲信号延长；</li>
<li>Synchronizer模块即用双锁存器法将得到的信号过渡到另一个时钟域；</li>
<li>Toggle2Pluse模块是Pluse2Toggle功能相对，即将延长的脉冲信号还原为单脉冲，这里用到了异或门</li>
</ol>
<p>整体的设计思想即用Pluse2Toggle将信号延长，用Synchronizer过渡，用Toggle2Pluse还原，以保证另一个时钟域可以正确采到，而接收方用相反的流程送回响应信号。</p>
<p><img src="https://i.loli.net/2020/03/14/f1wyv9tr5BeH2Xz.png" alt="跨时钟域2.4.png"></p>
<p>“结绳法”波形示意图如下所示。</p>
<p><img src="https://i.loli.net/2020/03/14/qysCvDAuLJ2FVlh.png" alt="跨时钟域2.5.png"></p>
<blockquote>
<p>在两次src_req_clk1之间被src_vld_clk1“结绳”(pluse2toggle)，在将src_vld_clk1用双锁存器同步以后，将该信号转换为dst_req_clk2(toggle2pluse)。同理，用dst_vld_clk2将dst_req_clk2“结绳”，dst_vld_clk2表明在clk2时钟域中，src_dat_clk1已经可以进行正确采样了。最后将dst_vld_clk2转换为dst_ack_clk1(synchronizer and toggle2pluse), dst_ack_clk1表明src_dat_clk1已经被clk2正确采样了， 此后clk1时钟域就可以安全地传输下一个数据了。可以看出，“结绳法”关键是将信号结绳以后，使其保持了足够长的时间，以便另一个时钟可以正确地采样。</p>
</blockquote>
<p><strong>小结：</strong></p>
<ol>
<li>
<p>结绳就是将单脉冲延长，以方便采集到的数据；</p>
</li>
<li>
<p>方法可归结为2类，利用脉冲的边沿做时钟；利用脉冲的电平（部分场合要求最小脉冲宽度）做选择器或者异步复位；</p>
</li>
<li>
<p>关键点在于是什么时候结绳结束；</p>
</li>
<li>
<p>操作方法有2种，利用采集到的脉冲做异步复位，置位；利用采集到的脉冲再次结绳采集做握手响应信号；</p>
</li>
<li>
<p>结绳法可以解决快时钟域向慢时钟域过渡的问题，且其适用范围很广；</p>
</li>
<li>
<p>结绳法实现较为复杂，特别是效率不高，在对设计性能要求较高的场合应该慎用。</p>
</li>
</ol>
<h2 id="考虑两个问题"><a class="header-anchor" href="#考虑两个问题"></a>考虑两个问题</h2>
<hr>
<ol>
<li>
<p>采样中“快到慢”与“慢到快”在考虑问题时有什么区别？</p>
<p>慢到快，只需要考虑亚稳态问题；</p>
<p>快到慢，除亚稳态问题外，还需要考虑慢时钟的采样速率问题。。</p>
</li>
<li>
<p>为什么不能用慢时钟直接采样快时钟域的信号？</p>
<p>因为根据采样定理，采样频率低于信号最高频率2倍的时候，是无法完整采样的</p>
</li>
</ol>
<h2 id="多bit指示信号的跨时钟域传输"><a class="header-anchor" href="#多bit指示信号的跨时钟域传输"></a>多bit指示信号的跨时钟域传输</h2>
<hr>
<p>同时传递两个信号（b_load &amp; b-en）,如下图所示。</p>
<p><img src="https://i.loli.net/2020/03/14/rZtiKzgWPwFJvOp.png" alt="跨时钟域2.6.png"></p>
<p>图中b_load 和b_en同步至a_clk时钟域，如果这两个信号有一个小的skew，将导致a_clk时钟域中两个信号并不是在同一个时刻起作用，与两个信号在b_clk时钟域中的逻辑关系不同。</p>
<p><strong>多个控制信号跨时钟域仅仅通过简单的同步器同步有可能是不安全的</strong></p>
<p>解决方法：将b_load和b_en信号在b_clk时钟域中合并成一个信号b_lden,然后同步至a_clk中</p>
<p><img src="https://i.loli.net/2020/03/14/qQm6bYljCcKgJaM.png" alt="跨时钟域2.7.png"></p>
<p>如果遇到不能同步的情况，如译码信号，如下图所示。</p>
<p><img src="https://i.loli.net/2020/03/14/uoz4bkJXtyfNFlj.png" alt="跨时钟域2.8.png"></p>
<p>解决方法1：建议加入另一个控制信号，确保bdec[0]、bec[1]稳定时再进行采样。</p>
<p><img src="https://i.loli.net/2020/03/14/9bOxfk3SRXqaudc.png" alt="跨时钟域2.8.1.png"></p>
<p>解决方法2：在发送时钟域解码，通过同步器来同步发送时钟域的输出到新的时钟域。<strong>在新的时钟域内，使用状态机确定何时被同步的输入有效。</strong></p>
<p><img src="https://i.loli.net/2020/03/14/CPA7MctDQSjaRYs.png" alt="跨时钟域2.8.2.png"></p>
<h2 id="多bit数据流的跨时钟域传输"><a class="header-anchor" href="#多bit数据流的跨时钟域传输"></a>多bit数据流的跨时钟域传输</h2>
<hr>
<p>数据流和指示信号的区别：</p>
<ul>
<li>数据流大多具有连续性，即背靠背传输；</li>
<li>数据流要求信号具有较快的传输速度</li>
</ul>
<p><strong>解决方法：SRAM、FIFO</strong></p>
<h3 id="FIFO基本介绍"><a class="header-anchor" href="#FIFO基本介绍"></a>FIFO基本介绍</h3>
<p>FIFO（first in first out），是一种先进先出的存储结构。与普通存储器相比没有外部的读写地址线，使用简单。</p>
<p>缺点在于只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。</p>
<p>**异步FIFO即用一种时钟写入数据，而用另外一种时钟读出数据，其中这两个读写时钟是异步的。**适用于大量数据跨时钟域传输，且对传输速度有一定要求的场合。</p>
<p><img src="https://i.loli.net/2020/03/14/M4bmUsfjvAeDKW3.png" alt="跨时钟域2.9.png"></p>
<p>FIFO 上游节点是FIFO的数据输入端，在写信号有效时，数据将被写入FIFO的顶部（由FIFO内部的写指针控制），并且在FIFO内部，写指针后移一个单元，同时FIFO的满信号（FIFO full signal）将控制上游节点是否发送数据；</p>
<p>FIFO 下游节点是FIFO 的数据输出端，当读信号有效时，位于FIFO底部的数据将被读出（由FIFO内部的读指针控制），并且在FIFO内部读指针将后移一个单元，同时FIFO空信号（FIFO empty signal）将控制下游节点是否读出数据。</p>
<h3 id="FIFO主要用途："><a class="header-anchor" href="#FIFO主要用途："></a>FIFO主要用途：</h3>
<ul>
<li>
<p>使用异步FIFO对不同时钟域之间的数据进行传输；</p>
</li>
<li>
<p>对于不同宽度的数据接口也可以用FIFO</p>
<p>例如单片机8位数据输出，而DSP可能是16位数据输入，在单片机与DSP连接时就可以使用FIFO来达到数据匹配目的。</p>
</li>
</ul>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
<p>2.<a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf" target="_blank" rel="noopener">Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs</a></p>
<p>3.<a href="https://d1.amobbs.com/bbs_upload782111/files_35/ourdev_612485SWPQTC.pdf" target="_blank" rel="noopener">ASIC中的异步时序设计</a></p>
]]></content>
      <categories>
        <category>数字IC设计基础</category>
      </categories>
      <tags>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>亚稳态</title>
    <url>/2020/%E4%BA%9A%E7%A8%B3%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>亚稳态的概念，常见的三种同步器，电平同步器、边沿检查同步器和脉冲同步器。</p>
<a id="more"></a>
<h2 id="同步电路和域异步电路"><a class="header-anchor" href="#同步电路和域异步电路"></a>同步电路和域异步电路</h2>
<p><strong>同步电路的定义</strong></p>
<p>电路中的所有受时钟控制的单元（例如flip-flop，register），全部由一个统一的全局时钟控制</p>
<p><img src="https://i.loli.net/2020/03/06/BcNd6LzaCu5XhEY.png" alt="亚稳态1.1.png"></p>
<p><strong>同步电路设计的优点</strong></p>
<ul>
<li>
<p>在同步设计中，EDA工具可以保证电路系统的时序收敛，有效避免了电路设计中竞争冒险现象；</p>
</li>
<li>
<p>由于触发器只有在时钟边缘才改变取值，很大限度地减少了整个电路受毛刺和噪声影响的可能。</p>
</li>
</ul>
<p><strong>同步电路设计的缺点</strong></p>
<ul>
<li>
<p>时钟偏斜（clock skew）</p>
</li>
<li>
<p>时钟抖动（clock jitter）</p>
</li>
<li>
<p>时钟树综合，需要加入大量的延迟单元，使得电路的面积和功耗大大增加。</p>
</li>
</ul>
<p><strong>全局异步电路的定义</strong></p>
<p>电路中的数据传输可以在任何时候发生，电路中没有一个全局的或者局部的控制时钟。</p>
<p><img src="https://i.loli.net/2020/03/06/xfFjSt4iXmLBH5a.png" alt="亚稳态1.2.png"></p>
<p><strong>异步电路设计的优点</strong></p>
<ul>
<li>模块化特性突出</li>
<li>对信号的延迟不敏感</li>
<li>没有时钟偏斜问题</li>
<li>有潜在的高性能特性</li>
<li>好的电磁兼容性</li>
<li>具有低功耗特性</li>
</ul>
<p><strong>异步电路设计的缺点</strong></p>
<ul>
<li>设计复杂</li>
<li>缺少相应的EDA工具支持</li>
<li>在大规模集成电路设计中应该避免采用异步电路设计</li>
</ul>
<p>同步时钟异步时钟的差别在于，同步时钟来源于统一锁相环PLL生成，这些时钟的相位和倍数都是可控的，如果来源于不同的PLL，即使两个时钟的频率相同也属于异步时钟。</p>
<h2 id="亚稳态相关概念和原理"><a class="header-anchor" href="#亚稳态相关概念和原理"></a>亚稳态相关概念和原理</h2>
<ul>
<li>亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态；</li>
<li>当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上；</li>
<li>在此期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去</li>
</ul>
<p>亚稳态不能从根本上消除，但可以通过采取一定的措施使其对电路的影响降低。下面的公式用于表征亚稳态的影响：</p>
<img src="https://i.loli.net/2020/03/06/ecyjG7C4lENb3Uv.png" alt="亚稳态1.3png.png" style="zoom: 50%;" />
<p>故障间隔平均时间MTBF越大，亚稳态的影响越小</p>
<blockquote>
<p>tmet -寄存器从时钟上升沿触发后的时序余量时间</p>
<p>fclk - 接收时钟域的时钟频率</p>
<p>fdata - 数据的变化频率</p>
<p>C1、C2 - 与器件有关的参数（固定值）</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/06/2Zskwl4OycgvqMD.png" alt="亚稳态1.4png.png"></p>
<p>Tmet时间是指正常没有亚稳态情况下，寄存器输出信号从源寄存器到目的寄存器的建立时间余量。</p>
<blockquote>
<p>Tmet = 采样时钟周期时间  - 输出信号正常的Tcq时间 - 数据到达下一级寄存器的输入端口的其他延时时间T_data - 下一级寄存器T_su时间</p>
</blockquote>
<p>由于Tcq和Tsu都由器件本身的工艺和工作环境决定，如果在时钟频率fclk和数据变化率固定的情况下，要增大Tmet值，那么设计者要做的只能是<strong>减小T_data值</strong>。</p>
<p><strong>最大程度的减小T_data，只能是不再两个寄存器之间添加任何逻辑。</strong></p>
<h2 id="同步策略—双锁存器电平同步器"><a class="header-anchor" href="#同步策略—双锁存器电平同步器"></a>同步策略—双锁存器电平同步器</h2>
<p>一个信号在过渡到另一个时钟域时，如果仅仅用一个触发器将其锁存，那么用一个触发器进行采样的结果可能是亚稳态。</p>
<p>双锁存器法，即在一个信号进入另一个时钟域之前，将信号用两个锁存器连续锁存两次，最后得到的采样结果可以消除亚稳态问题。</p>
<p><em>亚稳态现象</em></p>
<p><img src="https://i.loli.net/2020/03/06/bWxNAZf7ywGIV5F.png" alt="亚稳态1.5.png"></p>
<p><em>亚稳态信号的传播</em></p>
<p><img src="https://i.loli.net/2020/03/06/7M4qCkdSUmW8LBR.png" alt="亚稳态1.6.png"></p>
<p><em>亚稳态的解决及RTL实现</em></p>
<p><img src="https://i.loli.net/2020/03/06/bKAWFl5EOhNT9Bk.png" alt="亚稳态1.7.png"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>  synchronizer (   </span><br><span class="line">              bclk,          	<span class="comment">//目的时钟，与aclk异步的时钟</span></span><br><span class="line">              reset_b,        	<span class="comment">//全局异步复位信号</span></span><br><span class="line">              adat,         	<span class="comment">//异步输入信号，工作在aclk</span></span><br><span class="line">              bdat,         	<span class="comment">//同步器输出</span></span><br><span class="line">         );</span><br><span class="line"><span class="keyword">input</span>     bclk;</span><br><span class="line"><span class="keyword">input</span>     reset_b;</span><br><span class="line"><span class="keyword">input</span>     adapt;</span><br><span class="line"><span class="keyword">output</span>    bdat;</span><br><span class="line"><span class="keyword">wire</span>     bdat;</span><br><span class="line"><span class="keyword">reg</span>      bdat1;</span><br><span class="line"><span class="keyword">reg</span>      bdat2;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> bclk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_b)</span><br><span class="line"><span class="keyword">if</span> (reset_b)</span><br><span class="line">    &#123;bdat2,bdat1&#125; &lt;= <span class="number">2</span> ' b0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;bdat2,bdat1&#125; &lt;= &#123;bdat1,adat&#125;;</span><br><span class="line"><span class="keyword">assign</span> bdat = bdat2;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>优点是结构简单，易实现，但是增加了两级触发器延时。而且当快时钟域转到慢时钟域时，易造成慢时钟采样丢失（还未来得及采样，数据就变化了）。<strong>故常用于慢时钟转到快时钟域。</strong></p>
<p>使用条件：（慢时钟域–&gt;快时钟域）</p>
<ul>
<li>{clk_slow的周期} &gt; {(clk-fast的周期) + (路径延时)}，确保信号可以被clk_fast采样到（假设clk_fast&amp;clk_slow起始时刻相同求得）；</li>
<li>{data 数据变化间隔} &gt; {(clk_slow的周期) + 2*(clk_fast的周期) + (路径延时)}，确保所有的数据变化均能采集到。</li>
</ul>
<p>结论：</p>
<ul>
<li>两级触发器已经将MTBF变得足够大；</li>
<li>三级或者更多级虽然能将亚稳态出现概率降得更低，但影响电路效率；</li>
<li>增加寄存器进行同步的方法只是不断降低亚稳态出现的概率</li>
</ul>
<h2 id="亚稳态—单bit信号的跨时钟域传输"><a class="header-anchor" href="#亚稳态—单bit信号的跨时钟域传输"></a>亚稳态—单bit信号的跨时钟域传输</h2>
<h3 id="慢时钟域–-快时钟域"><a class="header-anchor" href="#慢时钟域–-快时钟域"></a>慢时钟域–&gt;快时钟域</h3>
<p>由慢时钟到快时钟域的传输，主要采用边沿检测同步器电路，可以检测输入信号的上升沿或下降沿。</p>
<p><img src="https://i.loli.net/2020/03/06/Rpl7SFvCEr3ayjK.png" alt="亚稳态1.8.png"></p>
<p>边沿检查电路实现的电路功能实际上是将慢时钟下一个周期的脉冲，搬移并缩小为快时钟下一个周期宽的脉冲。</p>
<p><img src="https://i.loli.net/2020/03/06/pt4owY1VFjacNmA.png" alt="亚稳态1.9.png"></p>
<p>适用条件：</p>
<p>输入数据的宽度必须比一个接收时钟周期加上一个同步触发器的hold时间要长，最安全的就是两个同步周期宽度。<em>慢时钟域的脉冲足够保持到被快时钟的同步器拿到</em></p>
<h3 id="快时钟域–-慢时钟域"><a class="header-anchor" href="#快时钟域–-慢时钟域"></a>快时钟域–&gt;慢时钟域</h3>
<p>通常采用脉冲同步器，基本功能是：从某个时钟域取出一个单时钟宽度脉冲，然后在新的时钟域中建立另一个单时钟宽度的脉冲。</p>
<p><img src="https://i.loli.net/2020/03/06/XuUxinRSgDtKPyW.png" alt="亚稳态1.10.png"></p>
<p>使用慢时钟直接去采集快时钟域下input信号采集不到，因此使用toggle 电路子啊快时钟域下对输入信号有效标定，获得toggle信号。随后，使用同步器同步toggle信号，在慢时钟域下最终获得两个有效的单周期脉冲output。</p>
<p><img src="https://i.loli.net/2020/03/06/FuXNlkeiyL9YPAK.png" alt="亚稳态1.11.png"></p>
<p>使用条件：</p>
<ul>
<li>输入脉冲之间的最小间隔必须等于两个同步器时钟周期；</li>
<li>如果输入脉冲相互过近，则新时钟域中的输出脉冲也紧密相邻，结果是输出脉冲宽度比 一个时钟周期宽；</li>
<li>当输入脉冲时钟周期大于两个同步器时钟周期时，这个问题更加严重；</li>
<li>这种情况下，如果输入脉冲相邻太近，则同步器就不能检测到每个脉冲。</li>
</ul>
<h2 id="三种同步器对比"><a class="header-anchor" href="#三种同步器对比"></a>三种同步器对比</h2>
<p><img src="https://i.loli.net/2020/03/06/XGbjk4R79xuEYsJ.png" alt="亚稳态1.12.png"></p>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
<p>2.SOC设计方法与实现_郭炜_中文课件</p>
]]></content>
      <categories>
        <category>数字IC设计基础</category>
      </categories>
      <tags>
        <tag>数字IC</tag>
      </tags>
  </entry>
  <entry>
    <title>Multiple Clocks</title>
    <url>/2020/Multiple-Clocks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多时钟交互路径如何检查建立时间和保持时间。</p>
<a id="more"></a>
<h2 id="Integer-Multiples"><a class="header-anchor" href="#Integer-Multiples"></a>Integer Multiples</h2>
<p>设计中经常会定义出现成整数倍数关系的时钟。这样的例子中，我们在相关的时钟（related clocks）中找出公共的时钟周期来进行STA分析。</p>
<blockquote>
<p>two clocks are related if they have a data path between their domains</p>
</blockquote>
<p>Here is an example that shows four related clocks:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">20</span> -waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports CLKM]</span><br><span class="line">create_clock -name CLKQ -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line">create_clock -name CLKP -period <span class="number">5</span> -waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports CLKP]</span><br></pre></td></tr></table></figure>
<p>当分析CLKP和CLKM时钟域时，公共的时钟基本周期为20ns，如下图所示。</p>
<p><em>Integer multiple clocks</em></p>
<p><img src="https://i.loli.net/2020/03/03/NMK1kfpQEFdYScy.png" alt="STA5.1.png"></p>
<blockquote>
<p>Expanding clock ‘CLKP’ to base period of 20.00 (old period was 5.00, added 6 edges).<br>
Expanding clock ‘CLKQ’ to base period of 20.00 (old period was 10.00, added 2 edges).</p>
</blockquote>
<p>简单分析可知，在 CLKP 15ns时刻出发至CLKM 20ns时刻捕获进行setup time check 最为严苛。而在CLKP&amp;CLKM 0ns时刻进行hold time check最为合理。时序报告这里不再贴出。</p>
<h2 id="Non-Integer-Multiples"><a class="header-anchor" href="#Non-Integer-Multiples"></a>Non-Integer Multiples</h2>
<p>考虑数据路径中两个clock domains的频率不成倍数关系时，例如，the launch<br>
clock is divide-by-8 of a common clock and the capture clock is divide-by-5<br>
of the common clock ，如下图所示。</p>
<p><em>Non-integer multiple clocks</em></p>
<p><img src="https://i.loli.net/2020/03/03/zXHKlTM8Gd9qije.png" alt="STA5.2.png"></p>
<p>时钟定义指令如下：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">8</span> -waveform &#123;<span class="number">0</span> <span class="number">4</span>&#125; [get_ports CLKM]</span><br><span class="line">create_clock -name CLKQ -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line">create_clock -name CLKP -period <span class="number">5</span> -waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports CLKP]</span><br></pre></td></tr></table></figure>
<p>STA分析时需寻找related clock的common period。例如，common period 分别有CLKQ&amp;CLKP：10ns，CLKM&amp;CLKQ：40ns，CLKM&amp;CLKP：40ns。</p>
<p>下面考虑CLKM clock domain 和CLKP clock domain，公共的周期为40ns。</p>
<blockquote>
<p>Expanding clock ‘CLKM’ to base period of 40.00 (old period was 8.00, added 8 edges).<br>
Expanding clock ‘CLKP’ to base period of 40.00 (old period was 5.00, added 14 edges).</p>
</blockquote>
<p><em>Setup and hold checks for non-integer multiple clocks</em></p>
<p><img src="https://i.loli.net/2020/03/03/tLM8K6wW7mgebjo.png" alt="STA5.3.png"></p>
<p>setup check 中必须要满足launch edge和capture edge 的clock最小时间要求。</p>
<ul>
<li>
<p>如果时序路径由CLKM 到CLKP，则在CLKM 24ns launch ，CLKP 25ns时capture最严苛；</p>
</li>
<li>
<p>如果时序路径由CLKP到CLKM，在CLKP 15ns，CLKM 16ns 时最严苛。</p>
</li>
</ul>
<p>hold check中时钟是在0ns时刻检查最严苛。</p>
<p>时序报告在此不一一列出。</p>
<h2 id="Phase-Shifted"><a class="header-anchor" href="#Phase-Shifted"></a>Phase Shifted</h2>
<p>下面两个时钟相差90度相移。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_clock -period <span class="number">2.0</span> -waveform &#123;<span class="number">0</span> <span class="number">1.0</span>&#125; [get_ports CKM]</span><br><span class="line">create_clock -period <span class="number">2.0</span> -waveform &#123;<span class="number">0.5</span> <span class="number">1.5</span>&#125; [get_ports CKM90]</span><br></pre></td></tr></table></figure>
<p><em>Phase-shifted clocks</em></p>
<p><img src="https://i.loli.net/2020/03/03/LOBXpFRM8dQa3Zb.png" alt="STA5.4.png"></p>
<p>对于setup time 而言，数据在CKM 0ns建立，于CKM90 0.5ns时进行建立时间检查。</p>
<p>对于hold check而言，我们得在建立时间检查中capture edge 的前一个周期时刻点进行检查。例如在launch 2ns时刻，此时于2.5ns时刻进行setup check，因此在前一个capture edge 0.5ns时刻进行hold check。</p>
<p>因此该例中对于hold check 是十分有利的，因为hold time check中，数据捕获路径clock的时刻早于数据建立clock的时间。</p>
<h2 id="Half-Cycle-Paths"><a class="header-anchor" href="#Half-Cycle-Paths"></a>Half-Cycle Paths</h2>
<p>设计中同时存在negative-edge triggered flip-flops(active clock edge is falling edge)和positive-edge triggered flip-flops (active clock edge is rising edge)时，就可能属于half-cycle paths。</p>
<blockquote>
<p>A half-cycle path could be from a rising edge flip-flop to a falling edge flip-flop, or vice versa.</p>
</blockquote>
<p><em>A half-cycle path</em></p>
<p><img src="https://i.loli.net/2020/03/03/XpQrmiOVIovRUzD.png" alt="STA5.5.png"></p>
<p>下降沿出现在6ns时刻，上升沿在12ns时刻。因此，数据经过半个时钟周期，6ns，传输到捕获路径触发器 ，在半个时钟周期内进行建立时间检查。</p>
<p>保持时间检查中，通常于捕获边沿的前一个时钟周期检查。因此，12ns时刻捕获，前一个捕获边沿是0ns时刻。这样，实际上为保持时间检查增加了half-cycle margin，使保持检查结果有很大的positive slack。</p>
<p><em>the setup timing check path report</em></p>
<p><img src="https://i.loli.net/2020/03/03/ZbQUXJrzFI4VmjA.png" alt="STA5.6.png"></p>
<p><em>the hold timing path</em></p>
<p><img src="https://i.loli.net/2020/03/03/7ERZPQrKIxYAbwM.png" alt="STA5.7.png"></p>
<h2 id="False-Path"><a class="header-anchor" href="#False-Path"></a>False Path</h2>
<p>电路中某些timing paths有可能是不存在或者在设计中没有实际作用的。这些路径我们可以设置为false paths，使得STA在分析过程中忽略掉。</p>
<p>False paths的例子：</p>
<ul>
<li>from one clock domain to another clock domain;</li>
<li>from a clock pin of a flip-flop to the input of another flip-flop;</li>
<li>through a pin of a cell;</li>
<li>through pins of multiple cells;</li>
<li>or a combination of these</li>
</ul>
<p>A false path is set using the set_false_path specification. Here are some examples.</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_false_path -from [get_clocks SCAN_CLK] \</span><br><span class="line">-to [get_clocks CORE_CLK]</span><br><span class="line"><span class="comment"># Any path starting from the SCAN_CLK domain to the</span></span><br><span class="line"><span class="comment"># CORE_CLK domain is a false path.</span></span><br><span class="line">set_false_path -through [get_pins UMUX0/S]</span><br><span class="line"><span class="comment"># Any path going through this pin is false.</span></span><br><span class="line">set_false_path \</span><br><span class="line">-through [get_pins SAD_CORE/RSTN]]</span><br><span class="line"><span class="comment"># The false path specifications can also be specified to,</span></span><br><span class="line"><span class="comment"># through, or from a module pin instance.</span></span><br><span class="line">set_false_path -to [get_ports TEST_REG*]</span><br><span class="line"><span class="comment"># All paths that end in port named TEST_REG* are false paths.</span></span><br><span class="line">set_false_path -through UINV/Z -through UAND0/Z</span><br><span class="line"><span class="comment"># Any path that goes through both of these pins</span></span><br><span class="line"><span class="comment"># in this order is false.</span></span><br></pre></td></tr></table></figure>
<p><em>Few recommendations on setting false paths are given below.</em></p>
<p>To set a false path between two clock domains, use:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_false_path -from [get_clocks clockA] \</span><br><span class="line">-to [get_clocks clockB]</span><br></pre></td></tr></table></figure>
<p>instead of:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_false_path -from [get_pins &#123;regA_*&#125;/CP] \</span><br><span class="line">-to [get_pins &#123;regB_*&#125;/D]</span><br></pre></td></tr></table></figure>
<p><strong>The second form is much slower.</strong></p>
<p><strong>Another recommendation is to minimize the usage of -through options, as it adds unnecessary runtime complexity.</strong> The -through option should only be used where it is absolutely necessary and there is no alternate way to specify the false path.</p>
<p><strong>From an optimization perspective, another guideline is to not use a false path when a multicycle path is the real intent.</strong> If a signal is sampled at a known or predictable time, no matter how far out, a multicycle path specification should be used so that the path has some constraint and gets optimized to meet the multicycle constraint.</p>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://link.springer.com/content/pdf/bfm%3A978-0-387-93820-2%2F1.pdf" target="_blank" rel="noopener">Static Timing Analysis for Nanometer Designs A Practical Approach</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>Timing across Clock Domains</title>
    <url>/2020/2020-03-01-Timing-across-Clock-Domains/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>快慢时钟交互路径如何检查建立时间和保持时间</p>
 <a id="more"></a>
<h1>Slow to Fast Clock Domains</h1>
<p>按下列命令定义Clock:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">20</span> -waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports CLKM]</span><br><span class="line">create_clock -name CLKP -period <span class="number">5</span> -waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports CLKP]</span><br></pre></td></tr></table></figure>
<p><em>Path from a slow clock to a faster clock</em></p>
<p><img src="https://i.loli.net/2020/03/01/x7XgV3cKHMfas9Y.png" alt="STA4.1.png"></p>
<p>当 launch flip-flop 和capture flip-flop时钟频率不同时，STA首先需要确定公共的周期</p>
<p><em>Setup and hold checks with slow to fast path</em></p>
<p><img src="https://i.loli.net/2020/03/01/JFPeac2AMBQkV5p.png" alt="STA4.2.png"></p>
<p>如上图所示，在快时钟的第一个时钟周期进行setup/hold检查，这也是最严苛的检查，有如下结果。</p>
<p>Setup time check 时序报告：</p>
<p><img src="https://i.loli.net/2020/03/01/xeDVXNYmaWhs7KP.png" alt="STA4.3.png"></p>
<p>hold time check 时序报告：</p>
<p><img src="https://i.loli.net/2020/03/01/TkYIrztawg2l3M5.png" alt="STA4.4.png"></p>
<p>但是实际情况中，组合逻辑延时可能会很大，远大于一个快时钟周期。因此用快时钟的第一个时钟周期来检查时序，是不合理的。根据实际延时，我们可以通过特殊指令，指定在后面第几个时钟周期进行检查。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">4</span> -setup -from [get_clocks CLKM] -to [get_clocks CLKP] -end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The -end specifies that the multicycle of 4 refers to the end point or the capture clock.</p>
</blockquote>
<p><em>Multicycle of 4 between clock domains</em><br>
<img src="https://i.loli.net/2020/03/01/CxLa2IE5ijuNB8R.png" alt="STA4.5.png"></p>
<p>通过上述命令后，setup time check 在20ns时刻，hold time check 在15ns时刻。</p>
<p>Setup time check 时序报告：</p>
<p><img src="https://i.loli.net/2020/03/01/lzbyeaXTuxOPhQm.png" alt="STA4.6.png"></p>
<p>hold time check 时序报告：</p>
<p><img src="https://i.loli.net/2020/03/01/6LAiWREQpydqMob.png" alt="STA4.7.png"></p>
<p>在hold time check 的报告中，可以发现slack为负值，是违例的。在大多数设计中，数据的保持时间都比较短，所以在第一个时钟边沿，即launch edge 对应的时间边沿处检查是更能符合实际的。为实现这一点，我们需要hold time check做如下约束。</p>
 <figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">3</span> -hold  -from [get_clocks CLKM] -to [get_clocks CLKP] -end</span><br></pre></td></tr></table></figure>
<p><em>Hold time relaxed with multicycle hold specification</em></p>
<p><img src="https://i.loli.net/2020/03/01/CPNjQ5eBEvWzRUL.png" alt="STA4.8.png"></p>
<p>hold time check 时序报告：</p>
<p><img src="https://i.loli.net/2020/03/01/ZDqOS7jEbTrPa5t.png" alt="STA4.9.png"></p>
<p>总结一下，慢时钟到快时钟周期进行检查，可以设置在第N个快时钟周期来检查setup，同样也可以设置在第N个时钟周期对应的hold time check时间点的前N-1个时钟周期进行hold检查，这样更能贴合保持时间检查的实际情况。</p>
<h1>Fast to slow Clock Domains</h1>
<p>通过下列命令，定义快时钟CLKP和慢时钟CLKM：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_clock -name CLKM -period <span class="number">20</span> -waveform &#123;<span class="number">0</span> <span class="number">10</span>&#125; [get_ports CLKM]</span><br><span class="line">create_clock -name CLKP -period <span class="number">5</span> -waveform &#123;<span class="number">0</span> <span class="number">2.5</span>&#125; [get_ports CLKP]</span><br></pre></td></tr></table></figure>
<p>Path from fast clock to slow clock domain如下图所示，存在4种setup timing checks possible，以最严格的setup4为例检查setup time。</p>
<p><img src="https://i.loli.net/2020/03/01/ofS3F1UvID4Ri9Y.png" alt="STA4.10.png"></p>
<p>Setup time check 时序报告：</p>
<p><img src="https://i.loli.net/2020/03/01/5OLJNHDsfRwPBEV.png" alt="STA4.11.png"></p>
<p>最严格的保持时间检查是在快时钟的第一个时钟周期setup1 0ns时，确保capture edge 在0ns时不会捕获到launch flip-flop将要改变的数据。</p>
<p><img src="https://i.loli.net/2020/03/01/rwCXEFpYBSyj8fW.png" alt="STA4.12.png"></p>
<p>同slow to fast clock domains setup/hold time check一样，我们可以通过设置约束调整快时钟的默认周期的数据发射边沿，设置其在第几个时钟周期进行建立时间检查，让慢时钟进行建立时间检查。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_multicycle_path <span class="number">2</span> -setup -from [get_clocks CLKP] -to [get_clocks CLKM] -start</span><br><span class="line">set_multicycle_path <span class="number">1</span> -hold -from [get_clocks CLKP] -to [get_clocks CLKM] -start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The -start option refers to the launch clock and is the default for a multicycle hold.</p>
</blockquote>
<p>As expected, the launch clock edge is at 10ns and the capture clock edge is at 20ns，The hold check is at 0ns where both the capture and launch clocks have rising edges.</p>
<p><em>Setup multicycle of 2</em></p>
<p><img src="https://i.loli.net/2020/03/01/Eh4GYrVkie2unDF.png" alt="STA4.13.png"></p>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://link.springer.com/content/pdf/bfm%3A978-0-387-93820-2%2F1.pdf" target="_blank" rel="noopener">Static Timing Analysis for Nanometer Designs A Practical Approach</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>单周期路径的setup/hold time check</title>
    <url>/2020/2020-02-29-%E5%8D%95%E5%91%A8%E6%9C%9F%E8%B7%AF%E5%BE%84%E7%9A%84setup-hold-time-check/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要分析单周期时序路径下setup/hold time check</p>
<a id="more"></a>
<h1>单周期路径下setup time check</h1>
<h2 id="Input-to-Flip-flop-Path"><a class="header-anchor" href="#Input-to-Flip-flop-Path"></a>Input to Flip-flop Path</h2>
<p>时序报告：</p>
<p><img src="https://i.loli.net/2020/02/29/dFhK1PumQM674z5.png" alt="STA3.1.png"></p>
<p>input port clocked by VIRTUAL_CLKM，可以认为是由一个在设计外面的imaginary（virtual）flip-flop驱动的input port。另外，从该clock pin到达input port INA的max delay 可以被定义为一个确定的数值，在报告中为input external delay。通过以下SDC commands可以实现上述操作：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">create_clock -name VIRTUAL_CLKM -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">set_input_delay -<span class="keyword">clock</span> VIRTUAL_CLKM -max <span class="number">2.55</span> [get_ports INA]</span><br></pre></td></tr></table></figure>
<p>同时可以注意到DUA中经过input port INA，和其连接的第一个cell UINV1，可以通过specifying the driving cell of the input port INA计算delay：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_driving_cell -lib_cell BUFF -library lib013lwc [get_ports INA]</span><br></pre></td></tr></table></figure>
<h3 id="Setup-check-for-the-path-through-input-port"><a class="header-anchor" href="#Setup-check-for-the-path-through-input-port"></a>Setup check for the path through input port</h3>
<p><img src="https://i.loli.net/2020/02/29/uyT9sEJf4aIpPFv.png" alt="STA3.2.png"></p>
<h2 id="Flip-flop-to-Output-Path"><a class="header-anchor" href="#Flip-flop-to-Output-Path"></a>Flip-flop to Output Path</h2>
<p>类似于input port 约束，output port 也可以受virtual clock，internal clock of the design，input clock port，output clock port约束。下面是output pin ROUT constraint with respect to a virtual clock。如下：</p>
 <figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_output_delay -<span class="keyword">clock</span> VIRTUAL_CLKP -max <span class="number">5.1</span> [get_ports ROUT]</span><br><span class="line">set_load <span class="number">0.02</span> [get_ports ROUT]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To determine the delay of the last cell connected to the output port correctly,one needs to specify the load on this port.</p>
<p>The output load is specified above using the <em>set_load</em> command.</p>
</blockquote>
<h3 id="Setup-check-for-path-through-output-port"><a class="header-anchor" href="#Setup-check-for-path-through-output-port"></a>Setup check for path through output port</h3>
<p><img src="https://i.loli.net/2020/02/29/WNVHDpCyTtdJ3u5.png" alt="STA3.3.png"></p>
<p>时序报告：</p>
<p><img src="https://i.loli.net/2020/02/29/ONaM34jEuR7lVfG.png" alt="STA3.4.png"></p>
<blockquote>
<p>Notice that the output delay specified appears as output external delay and behaves like a required setup time for the virtual flip-flop</p>
</blockquote>
<p>因为 output external delay应该对应于virtual flip-flop的launch path中，但此处路径已在ROUT终止，因此将其放于capture path中，表现为负值。</p>
<p>总结：</p>
<p><code> slack = （Tcapture + Tcycle - Tuncertainty - Tsetup - Toutput_dealy）- （Tlaunch + Tck2q + Tdp）</code></p>
<h2 id="Input-to-Output-Path"><a class="header-anchor" href="#Input-to-Output-Path"></a>Input to Output Path</h2>
<p>和先前input path、output path类似，使用Virtual clocks来约束input&amp;output ports。通过以下指令进行约束：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_input_delay -<span class="keyword">clock</span> VIRTUAL_CLKM -max <span class="number">3.6</span> [get_ports INB]</span><br><span class="line">set_output_delay -<span class="keyword">clock</span> VIRTUAL_CLKM -max <span class="number">5.8</span> [get_ports POUT]</span><br></pre></td></tr></table></figure>
<h3 id="Combinational-path-from-input-to-output-port"><a class="header-anchor" href="#Combinational-path-from-input-to-output-port"></a>Combinational path from input to output port</h3>
<p><img src="https://i.loli.net/2020/02/29/HSAJg9DBMGdphuV.png" alt="STA3.5.png"></p>
<p>时序报告：</p>
<p><img src="https://i.loli.net/2020/02/29/FJOdvztUEQjZYoC.png" alt="STA3.6.png"></p>
<h1>单周期路径下hold time check</h1>
<p>Hold timing check确保使flip-flop能够捕获其原始的正确数据，保证前一级flip-flop输出值变化不会经过capture flip-flop，覆盖输出数据 。</p>
<p>Hold time 要求flip-flop在时钟的有效沿之后的指定时间段内，被锁存的数据应保持稳定。</p>
<p><img src="https://i.loli.net/2020/02/29/QYsN1Fc2GlKyOdi.png" alt="STA3.7.png"></p>
<p>hold timing check 和setup timing check 有如下差别：</p>
<blockquote>
<p>The hold check is from one active edge of the clock in the launch flip-flop to the same clock edge at the capture flip-flop.</p>
<p>Thus, a hold check is independent of the clock period.</p>
<p>The hold check is carried out on each active edge of the clock of the capture flip-flop.</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/29/npwRDSoOLria3CF.png" alt="STA3.8.png"></p>
<p><img src="https://i.loli.net/2020/02/29/uQOK72X1WxaHctR.png" alt="STA3.9.png"></p>
<p>The hold check can be mathematically expressed as:</p>
<p><img src="https://i.loli.net/2020/02/29/iHVeXdlkhg1fFEW.png" alt="STA3.10.png"></p>
<p><code>Slack = (Tlaunch + Tck2q + Tdp) - (Tcapture + Thold)</code></p>
<p>Hold time check 对capture flip-flop上数据引脚的路径施加了下限或最小值限制。需要确定到捕获触发器D引脚的最快路径。 这意味着将始终使用最短路径来验证hold checks。 因此，通常在fast timing corner 中执行hold checks。</p>
<h2 id="Hold-time-check-和setup-time-check-之间的关系"><a class="header-anchor" href="#Hold-time-check-和setup-time-check-之间的关系"></a>Hold time check 和setup time check 之间的关系</h2>
<p>如下图所示，hold timing check 确保:</p>
<ul>
<li><em>Data from the subsequent launch edge must not be captured by the setup receiving edge.</em></li>
<li><em>Data from the setup launch edge must not be captured by the preceding receiving edge.</em></li>
</ul>
<p><strong>Two hold checks for one setup check</strong></p>
<p><img src="https://i.loli.net/2020/02/29/lRH74hbNPJdvOsn.png" alt="STA3.11.png"></p>
<blockquote>
<p>UFF0 ：launch flip-flop，UFF1：capture flip-flop</p>
<p>Setup check：setup launch edge --&gt; setup receiving edge</p>
</blockquote>
<p><strong>The subsequent launch edge must not propagate data so fast that the setup receiving edge does not have time to capture its data reliably.</strong></p>
<p><strong>The setup launch edge must not propagate data so fast that the preceding receiving edge does not get a chance to capture its data.</strong></p>
<p>While setup violations can cause the operating frequency of the design to be lowered, the hold violations can kill a design, that is, make the design inoperable at any frequency. Thus it is very important to understand the hold timing checks and resolve any violations.</p>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://link.springer.com/content/pdf/bfm%3A978-0-387-93820-2%2F1.pdf" target="_blank" rel="noopener">Static Timing Analysis for Nanometer Designs A Practical Approach</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>reg2reg setup time 分析</title>
    <url>/2020/2020-02-29-Path-reg2reg-setup-time-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单地对<em>寄存器到寄存器路径</em>建立时间的报告进行了分析</p>
<a id="more"></a>
<h2 id="理想的时钟网络"><a class="header-anchor" href="#理想的时钟网络"></a>理想的时钟网络</h2>
<p><img src="https://i.loli.net/2020/02/29/ec9qmofu2OEhbXv.png" alt="STA2.1.png"></p>
<p>可以先分析出下面几个问题：</p>
<blockquote>
<p>1.what are the start point and the end point of this path？</p>
<p>2.Which Path Group is this path belong to？</p>
<p>3.Path Type？</p>
<p>4.Constrain？</p>
</blockquote>
<p>分析可知，</p>
<ul>
<li>
<p>Start point: the launch flip-flop UFF0;End point: the capture flip-flop UFF1</p>
</li>
<li>
<p>Path group:归属于CLKM</p>
</li>
<li>
<p>Path Type ：max，意味着报告中所有路径区最大延时，对应setup time check</p>
</li>
<li>
<p>Constraints:</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">  create_clock -name CLKM -period <span class="number">10</span> -waveform &#123;<span class="number">0</span> <span class="number">5</span>&#125; [get_ports CLKM]</span><br><span class="line">  set_clock_uncertainty -setup <span class="number">0.3</span> [all_clocks]</span><br><span class="line">  set_clock_transition -rise <span class="number">0.2</span> [all_clocks]</span><br><span class="line">set_clock_transition -fall <span class="number">0.15</span> [all_clocks]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置 clock uncertainty可以加紧约束</p>
</blockquote>
</li>
</ul>
<p>总结报告，对于flip-flop path：</p>
<ul>
<li>
<p>launch path： 时钟由源点出发，经过Tlaunch = 0，经过flip-flop CLK2Q 延时Tck2q = 0.16，经过组合逻辑延时Tdp=0.04+0.05，最终到达时序路径终点UFF1/D，Data arrival time = 0.26；</p>
</li>
<li>
<p>Capture path：时钟源点加上一个时钟周期，经过理想的时钟网络，最终到达终点UFF1/CK。data required time 还需要减掉 clock uncertainty 和 library setup time，得到data required time = 9.66；</p>
</li>
<li>
<p>Slack = data required time - data arrival time，slack 大于0则满足约束，具体公式总结如下图所示。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/29/UavV19MIKOT32cR.png" alt="STA2.2.png"></p>
<h2 id="时钟网络有一个确定的延时值"><a class="header-anchor" href="#时钟网络有一个确定的延时值"></a>时钟网络有一个确定的延时值</h2>
<p>上面报告中clock network delay是一个理想的值（marked as ideal），这意味着clock trees被认为是理想的，即clock path上所有的buffer delay都为0。显然，当时钟树被建立之后，clock paths会先显示真实的delays（marked as propagated），如下图所示。</p>
<p><img src="https://i.loli.net/2020/02/29/efwkadL7CAlOmNx.png" alt="STA2.3.png"></p>
<p><strong>后一个时钟为0.12比前一个触发器的时钟要晚到一点，差值012-0.11=0.01称之为时钟的<em>偏斜</em>。</strong></p>
<p>**另外时序报告中标有“r”和“f”，分别代表clock或数据信号的rising and falling edge。**因为是建立时间检查，所以通常取上升或下降沿延迟中的最大延迟值。</p>
<h3 id="两种类型的clock-latencies"><a class="header-anchor" href="#两种类型的clock-latencies"></a>两种类型的clock latencies</h3>
<p><em>clock source latency &amp; clock network latency</em></p>
<ul>
<li>
<p>Clock source latency：也称insertion delay，是由时钟源传播至当前分析时钟定义点所花费的时间。</p>
<p>Source latency 不会影响内部设计的时序分析，因为它被同时加到launch clock 和capture clock。</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">set_clock_latency -<span class="keyword">source</span> -rise <span class="number">0.7</span> [get_clocks CLKM]</span><br><span class="line"></span><br><span class="line">set_clock_latency -<span class="keyword">source</span> -fall <span class="number">0.65</span> [get_clocks CLKM]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Clock network latency：如果不使用 -source 命令，命令定义的则为clock network latency，是由DUA中时钟定义点到flip-flop clock pin的时间。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/29/xhVU1BYlvqLASFe.png" alt="STA2.4.png"></p>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://link.springer.com/content/pdf/bfm%3A978-0-387-93820-2%2F1.pdf" target="_blank" rel="noopener">Static Timing Analysis for Nanometer Designs A Practical Approach</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>静态时序分析(STA)基础</title>
    <url>/2020/2020-02-28-%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90-STA-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>什么是静态时序分析？</h1>
<p>静态时序分析是一种不使用动态仿真，来检查电路是否满足时序约束的分析方法。</p>
<ul>
<li>Much faster than timing-driven，gate-level simulation</li>
<li>Proper circuit functionality is not checked</li>
<li>Vector generation NOT required</li>
</ul>
<a id="more"></a>
<p><strong>STA Flow</strong></p>
<p><img src="https://i.loli.net/2020/02/28/X5Znv6eS2cNU1rM.png" alt="STA1.1.png"></p>
<p><strong>STA VS Event Simulation(互补)</strong></p>
<p><img src="https://i.loli.net/2020/02/28/orh4VdtEMfavs9J.png" alt="STA1.2.png"></p>
<h1>How STA Work？</h1>
<blockquote>
<p>Three Steps in Static Timing Analysis</p>
<p>1.Design is broken down into sets of timing paths；</p>
<p>2.Delay of each path is calculated；</p>
<p>3.Path delays are checked to see if timing constraints have been met</p>
</blockquote>
<p>需要准备的文件和分析结果：</p>
<p><img src="https://i.loli.net/2020/02/28/LS5eI1m7P4MjC9i.png" alt="STA1.3.png"></p>
<p><strong><em>Setup Time</em>-时钟边沿到来之前数据必须保持稳定的时间长度。</strong></p>
<p><img src="https://i.loli.net/2020/02/28/DjZ5OLVgKyCuh8I.png" alt="STA1.4.png"></p>
<p><strong><em>Hold Time</em>-时钟边沿到来之后，输入引脚的输入数据依然要保持稳定的时间长度。</strong></p>
<p><img src="https://i.loli.net/2020/02/28/CvwhO3KfENjklse.png" alt="STA1.5.png"></p>
<p><em><strong>Time Slack</strong></em></p>
<p>Slack is the difference between the required time and the time that a signal arrives.</p>
<ul>
<li>Positive slack or zero means meet constraints</li>
<li>Negative slack means violate constraint</li>
</ul>
<p><img src="https://i.loli.net/2020/02/28/LIZp64VMyHBn3hT.png" alt="STA1.6.png"></p>
<p><em><strong>Speed VS. slack</strong></em></p>
<ul>
<li>整个同步电路系统的最大工作频率（minimum clock period）由最差逻辑路径所决定</li>
<li>Slack 与时钟频率是息息相关的，例如clock period = 10 ns</li>
</ul>
<p><img src="https://i.loli.net/2020/02/28/fkuajURY9V8emA6.png" alt="STA1.7.png"></p>
<p><em><strong>Power VS. slack</strong></em></p>
<p>如果 positive slack 较大，可以进步减小slack，使其保持为一个大于0的值。进一步缩小功耗和设计尺寸。</p>
<p>静态时序分析相比于逻辑综合时的时序分析区别在于，静态时序分析可以在逻辑综合、布局布线、时钟树综合每个阶段都可以进行的，越靠后延时信息分析越准确。</p>
<blockquote>
<p>There are 4 Types of PrimeTime paths:</p>
<ul>
<li>
<p>Input port to data pin of flip-flop(Path 1)</p>
</li>
<li>
<p>Clock pin of flip-flop to data pin of flip-flop (Path 2)</p>
</li>
<li>
<p>Clock pin of flip-flop to output port (Path 3)</p>
</li>
<li>
<p>Input port to output port (Path 4)</p>
</li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/02/28/7muHAlo2qieLJ4G.png" alt="STA1.8.png"></p>
<h1>建立时间的检查（setup check）</h1>
<blockquote>
<p>A setup timing check verifies the timing relationship between the clock and the data pin of a flip-flop so that the setup requirement is met.</p>
</blockquote>
<p>换句话说，建立时间的检查可以确保在flip-flop时钟有效沿到来时 ，数据到达flip-flop输入引脚时刻是稳定的。</p>
<p><img src="https://i.loli.net/2020/02/28/KeVuSCLax68nFMz.png" alt="STA1.9.png"></p>
<p>下面举一个简单的例子，如图所示，Launch &amp; capture flip-flop使用的是同一个时钟CLKM。</p>
<p>第一个时钟上升沿，CLKM 经Tlaunch延时到达launch flip-flop UFF0,通过该时钟沿在时刻Tlaunch + Tck2q + Tdp数据被建立。</p>
<p>第二个时钟沿(setup is normally checked after one cycle)在时刻Tcycle + Tcapture到达capture flip-flop UFF1。</p>
<p>以上两条路径之间的时间差别需要满足大于flip-flop的setup time，这样才能使得数据稳定的捕获到flip-flop中。</p>
<p><img src="https://i.loli.net/2020/02/28/RAZpB7gIHcxQhvC.png" alt="STA1.10.png"></p>
<p><img src="https://i.loli.net/2020/02/28/eBmcAXLkiQT69Js.png" alt="STA1.11.png"></p>
<p>The setup check can be mathematically expressed as:</p>
<p><img src="https://i.loli.net/2020/02/28/Ss4h9WpCB5o8vmJ.png" alt="STA1.12.png"></p>
<blockquote>
<ul>
<li>
<p>Tlaunch is the delay of the clock tree of the launch flip-flop UFF0;</p>
</li>
<li>
<p>Tdp is the delay of the combinational logic data path;</p>
</li>
<li>
<p>Tcycle is the clock period;</p>
</li>
<li>
<p>Tcapture is the delay of the clock tree for the capture flip-flop UFF1.</p>
</li>
</ul>
</blockquote>
<p>​        <strong>“<span style="color:red;"><u>  Since the setup check poses a max constraint, the setup check always uses the longest or the max timing path. </u> </span>For the same reason, this check is normally verified at the slow corner where the delays are the largest.”</strong></p>
<hr>
<p><em>Reference</em>：</p>
<p>1.<a href="https://link.springer.com/content/pdf/bfm%3A978-0-387-93820-2%2F1.pdf" target="_blank" rel="noopener">Static Timing Analysis for Nanometer Designs A Practical Approach</a></p>
<p>2.<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
]]></content>
      <tags>
        <tag>STA</tag>
      </tags>
  </entry>
  <entry>
    <title>RTL设计指导原则</title>
    <url>/2020/2020-02-28-RTL-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>RTL级设计的评判标准</h1>
<p>时序性能、所占面积、可测试性、可重用性、功耗、时钟域的分配、复位信号设计、是否与所用EDA工具匹配</p>
<p><strong>指导原则：面积与速度互换 、乒乓操作、 流水线设计</strong></p>
 <a id="more"></a>
<h1>面积与速度互换</h1>
<p>**面积：**一个设计所消耗的目标器件的硬件资源数量或者ASIC芯片的面积</p>
<p>**速度：**设计在芯片上稳定运行时所能够达到的最高频率，这个频率是有设计的时序状况决定</p>
<p><em>时钟周期、PAD to PAD Time、Clock Setup Time、Clock Hold Time、Clock-to-Output Delay</em></p>
<h1>面积与速度的平衡互换原则</h1>
<p>**设计面积小与运行频率高是对立统一的矛盾体。**科学的设计目标是：</p>
<ul>
<li>
<p>在满足设计时序要去（包含对设计最高频率的要求）的前提下，占用最小的芯片面积；</p>
</li>
<li>
<p>在所规定的面积下，使设计的时序余量更大，频率更高</p>
</li>
</ul>
<p><strong>设计如果时序余量较大，所能跑的频率远远高于设计要求：</strong></p>
<ul>
<li>通过功能模块复用减少整个设计所消耗的芯片面积，用速度的优势对换面积的节约。</li>
</ul>
<p><strong>设计的时序要求很高，普通方法达不到设计频率：</strong></p>
<ul>
<li>
<p>可以通过将数据流串并转换；</p>
</li>
<li>
<p>并行复制多个操作模块；</p>
</li>
<li>
<p>对整个设计采取乒乓操作和串并转换的细想进行处理；</p>
</li>
<li>
<p>在芯片输出模块处，在对数进行“并串转换”</p>
</li>
</ul>
<h1>乒乓操作</h1>
<p>“乒乓操作”是一个常常应用于数据流控制的处理技巧</p>
<p><em>数据缓冲模块可以为常用的存储的单元：双口RAM 单口RAM FIFO</em></p>
<p><img src="https://i.loli.net/2020/02/28/iu39eUqEYCwoOlV.png" alt="RTL4.1.png"></p>
<blockquote>
<p>第1个缓冲周期，将输入数据缓冲到模块1；</p>
<p>第2个缓冲周期，通过切换输入数据流选择单元，将输入数据缓冲到模块2。同时将数据缓冲模块1缓冲的数据，通过输出数据流选择单元进行的选择送到数据流运算模块进行运算处理；</p>
<p>第3个缓冲周期，通过输入数据流选择单元的再次切换，将输入数据缓冲到数据缓冲模块1.同时，将数据缓冲模块2缓冲的第2个周期的数据通过输出数据流选择单元的切换，送到数据流处理模块；</p>
<p>如此循环，完成数据的输入。</p>
</blockquote>
<p><strong>特点：</strong></p>
<p><img src="https://i.loli.net/2020/02/28/AaFQlTdCLjXwqEn.png" alt="RTL4.2.png"></p>
<p>乒乓操作的最大特点是<strong>通过“输入数据选择单元”和“输出数据选择单元”按节拍、相互配合的切换，将经过缓冲的数据流没有停顿地送到“数据流运算处理模块”进行运算与处理。<strong>把乒乓操作模块当做一个整体，站在这个模块的两端看数据，输入数据流和输出数据流都是连续不断的，没有任何停顿，因此非常适合对数据流进行流水线式处理。所以乒乓操作</strong>常常应用于流水线式算法，完成数据的无缝缓冲与处理。</strong></p>
<p>乒乓操作的第二个优点是可以<strong>节约缓冲区空间</strong>。另外，巧妙运用乒乓操作还可以达到用低速模块处理高速数据流的效果。如视频中实例展示，通过乒乓操作实现低速模块处理高速数据的实质是：通过DPRAM这种缓存单元实现了数据流的串并转换，并行用“数据预处理模块1”和“数据预处理模块2”处理分流的数据，<strong>是面积与速度互换原则的体现！</strong></p>
<p>通过乒乓操作实现低速模块处理高速数据的实质如下图所示。</p>
<p><img src="https://i.loli.net/2020/02/28/kX3Fbt2cgxhCAdO.png" alt="RTL4.3.png"></p>
<p>通过DPRAM这种缓存单元实现了数据流的串并转换，并行用“数据预处理模块1”和“数据预处理模块2”处理分流的数据，是面积与速度互换原则的体现。</p>
<h1>流水线</h1>
<p><strong>流水线的参数设计中，系统时钟取决于最慢的流水线级的延时。</strong></p>
<p>最长的组合逻辑链 --&gt; 最大的td值 --&gt; 系统时钟频率上限 --&gt; 系统速度上限</p>
<p><strong>组合逻辑链的并行闲置：</strong></p>
<p><img src="https://i.loli.net/2020/02/28/M4oCi1VAQPHOXlk.png" alt="RTL4.4.png"></p>
<p><strong>组合逻辑链的串行闲置：</strong></p>
<p><img src="https://i.loli.net/2020/02/28/e8vYCUQryDxE57m.png" alt="RTL4.5.png"></p>
<p>实例： 计算log(|a+b|)</p>
<p>组合逻辑的延时等于加法器，求绝对值，求对数的延时之和。如若插入两级寄存器之后，组合逻辑的延时等于三者绝对值的最大值，且每个时刻三部分都在运行。对比发现，流水线的工作方式可以充分提高电路运行的频率，理想情况下 ，本例中，运行频率可以提升至原来的三倍。</p>
<p><img src="https://i.loli.net/2020/02/28/6wUtXksvzRYJ49c.png" alt="RTL4.6.png"></p>
<p>四级流水线结构</p>
<p><img src="https://i.loli.net/2020/02/28/ybFXMzDqeUkifY9.png" alt="RTL4.7.png"></p>
<p>四级流水线比较</p>
<p><img src="https://i.loli.net/2020/02/28/CLSYxu5qfyWVw7h.png" alt="RTL4.8.png"></p>
<blockquote>
<p>注：Tpipe&lt;T（因流水线单元一定比非流水线单元短）;4Tpipe&gt;T（因流水线需要插入寄存器，寄存器有延迟）</p>
</blockquote>
<p><strong>特点：</strong></p>
<p>通过插入寄存器，将长的串行逻辑链分成较小的部分。当系统运算是串行的时候，利用时钟控制，使运算依照顺序接续进行。在任何给定时刻，大部分电路都在工作。</p>
<p><strong>好处：</strong></p>
<p>每一部分延时较小–&gt; 可使用更快的时钟</p>
<p>大部分电路同时进行运算–&gt;可提高数据通过量</p>
<p><strong>流水线参数设计</strong></p>
<p>系统时钟取决于最慢的流水线级的延时</p>
<p>流水线时钟周期 Tpipe=max{T1，T2，… ,Tm}</p>
<p>第i级的时钟周期 Ti&gt;tff + tsu + td,i + ts,i + 1</p>
<p>流水线分割点及级数的确定要考虑的因素包括：</p>
<ul>
<li>单元延迟时间及时钟频率的大小决定了数据通过速率；</li>
<li>过多的级数不一定能产生最快的结果；</li>
<li>太多寄存器的插入会导致芯片面积增加，布线困难，时钟偏差增加。</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>Balance in circuit design</title>
    <url>/2020/2020-02-28-Balance-in-circuit-design/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>01.EFR Scheme for Low Power SRAM；</em></p>
<p><em>02.Chip Architecture；</em></p>
<p><em>03.Results；</em></p>
<p><em>04.Source Line Voltage Control Technique</em></p>
<a id="more"></a>
<p>本文主要介绍一种新的设计架构来获得更低的静态功耗，电源电压控制技术（source line voltage control techniques）。传统设计中，power line的电压为某一常数值来保证SRAM稳定工作。在此，新方法中通过控制power line电压来改善漏电状况。</p>
<p>首先，描述了在手机低电压SRAM cell中使用的**electric field relaxation（EFR）**电路。<strong>采用更高的阈值电压，有助于减小SRAM cell的静态功耗</strong>。</p>
<p>其次，描述了在移动蜂窝电话应用处理器中集成的SRAM<strong>减小漏电流的设计技术</strong>。<strong>采用较低的阈值电压，有助于获得SRAM cell更低的获取时间（low access time）</strong>。</p>
<h1><em>EFR Scheme for Low Power SRAM</em></h1>
<p>EFR电路如图1所示，它能从电路级别消除泄漏电流。<strong>在保持阶段（retention mode），对于bit lines（BT and BB）用1.0V的供电替换原先1.5V的供电，同时VSSM从0提升到0.5V</strong>。</p>
<p><img src="https://i.loli.net/2020/02/28/mRG8OLKn5vijHZy.png" alt="memory4.1.png"></p>
<p>Fig. 1 Electric field relaxation scheme</p>
<p><strong>黑色的实线箭头表示bit lines（BT and BB）从1.5V替换为1.0V的差异</strong>。这种relaxation能减小gate leakage和GIDL currents大约90%。</p>
<p><strong>灰色的实线箭头表示负的0.5v VGS应用到transfer nMOS晶体管</strong>。负偏压能够将subthreshold leakagecurrent降到接近0。</p>
<p><strong>圆点的箭头表示负的0.5V back-bodybias电压VBB应用到driver nMOS晶体管</strong>。这个反偏压能减小subthreshold leakage current大约90%。</p>
<p>以上是MOS管的source电压和衬底之间电压由0变为0.5V的区别，但是，the band-to-band tunneling leakage仍然没有改善。</p>
<p>图2给出了在25℃（Fig.2a）和90℃（Fig.2b）温度环境下，对传统设计方式和EFR设计方式的SRAM cells在最坏的工艺环境下（the worst-case process）静态泄漏电流的测试数据。每种器件类型合计了subthreshold和GIDL currents。</p>
<p><img src="https://i.loli.net/2020/02/28/Qg7JOSoHqxdKilb.png" alt="memory4.2.png">Fig. 2 Measured SRAM cell leakagecurrent; (a) 25ıC/worst case (b) 90ıC/worst case</p>
<p>在两个例子中，pMOS的阈值电压为1.0V，在25℃和90℃中两者的subthreshold leakage均比GIDL currents小得多。nMOS的阈值电压为0.7V，subthreshold leakage current相对于GIDLcurrent在25℃更小，但在90℃更大。cell的静态泄漏功耗在EFR设计中25℃时为16.6fA，90℃时为101.7fA，分别相比于传统设计的cell小82.5%和91.8%。</p>
<h1><em>Chip Architecture</em></h1>
<p><img src="https://i.loli.net/2020/02/28/j5faidzXmlgFVbc.png" alt="memory4.3.png">Fig.3 Circuit diagram of one mat</p>
<p>图3展示了SRAM芯片某一簇（mat）的电路图，整个SRAM chip 有32 mats。每个mat由2048 word lines构成的256-data-bit和20-parity-bit columns组成，且每个mat被划分为4个bank。</p>
<p>读操作的仿真时序图在Fig4中展示。该SRAM是异步的，如果地址信号不发生改变SRAM将保持retention mode，<strong>如果地址信号改变，SRAM由retention mode转换为active mode，产生一个ATD 脉冲，激活reset 操作</strong>。</p>
<p><strong>在4.3ns的reset期间，选中的bank中memory cell的VSS line（VSSM）从0.5V下拉到0V，同时bit-line pairs（BT,and BB）从1.0V预充为1.5V</strong>。</p>
<p>传统异步SRAM中通常是在reset time时，bit-line pair由0v预充为1.5V，在我们的EFR电路设计中，我们可以容易的在reset time期间为bit-line预充和VSSM放电。另外，由于EFR电路和asynchronous SRAM上述类似，access time不会增加。</p>
<p><img src="https://i.loli.net/2020/02/28/8HLKbmp5lkYrAcW.png" alt="memory4.4.png"></p>
<p>Fig. 4 Simulated waveforms for readoperation</p>
<p><strong>随后word line（wl）激活。随着sense amplifiers的激活，选中的128 bits of data 和10 parity bits出现在local bus（LBUS）</strong>。为了减少对power supplies噪声的产生，VSSM被控制在bank level而不是在mat level。这种控制方法可以保持VSS的噪声低于32mV，这个结果在仿真中通过power supply nets可以观察得到。VSSM line由第三层金属加强来以控制VSSM从0.5到0V。在完成读操作的500us内，VSSM line非常慢的恢复到0.5V。在读操作完成的100ms内由漏电流作用，bit-line pairs容易的恢复回1.0V。因此，复位操作很难影响到动态功耗。</p>
<h1><em>Results</em></h1>
<p><img src="https://i.loli.net/2020/02/28/NiBFqxsgVILSGDM.jpg" alt="memory4.5.png"></p>
<p>Fig. 5 Photograph and features of thechip</p>
<h1><em>Source Line Voltage Control Technique</em></h1>
<p>本节描述聚焦于移动电话应用处理器的减小漏电流技术。通常，集成在应用处理器中的SRAM会使用较低的阈值电压。因此，主要的泄漏电流是subthreshold leakage current。为了减小SRAM cells在未选通状态下的泄漏电流，便提出了source line voltage control 技术，来控制powerline电压，并保持最小限度地牺牲操作稳定性。</p>
<p><strong>SRAM的Power supply voltage控制为VDD和VSS的中间电位，中间电位电压同时减小泄露电流以及数据保持电流</strong>。中间电压的产生由一个简单的电路实现，因为如果采用复杂电路，会有额外的功耗和面积代价。<strong>这一节介绍一个简单的电压控制电路，包括电压切换选择，电阻和二极管，此电路可以降低额外的功耗和面积代价</strong>。</p>
<p><img src="https://i.loli.net/2020/02/28/ALVXdw1abKkBSMJ.png" alt="memory4.6.png">Fig. 6 Leakage and stability vs. localpower line voltage</p>
<p>SRAM模块必须满足其性能目标，设计能实现足够稳定的保存数据。控制VSSM的电压来减小memory cell的leakage时，更高的VSSM能减小SRAM cell leakage到一个更小的级别。另一方面，也能破坏SRAM的数据保持稳定性。这样的关系在图6中描述。为了满足low leakage 和high stability，VSSM必须被控制到能满足leakage目标的最低电压。图7展示了VSSM控制电路，<strong>PLVC1，由3个NMOSFETS组成。一个NMOSFET作为在VSSM和VSS之间的电压切换（MS1），一个作为二极管（MD1），另一个作为电阻（MR1）</strong>。MR1有一个长的栅极且保持常开。</p>
<p><img src="https://i.loli.net/2020/02/28/CxKvrTI1EJUaH5d.png" alt="memory4.7.png"></p>
<p>Fig. 7 VSSM controller in embedded SRAM</p>
<p>由130nm制造工艺生产的memory，其cell的主要leakage current 是subthreshold current，很大程度受阈值电压变化的影响。例如，Vth减小100mV，subthreshold leakage增加超过十倍，而MOSFET的驱动电流仅增加10%。</p>
<p><strong>当制造的MOSFET 阈值电压Vth波动到一个高值，memory cell的leakage会大大减小。</strong></p>
<p><strong>因为MR1为开启状态，电流通过MR1轻微的减小。如果MR1的电流比memory cell leakage电流大，VSSM电压变低。</strong></p>
<p><strong>当阈值电压Vth波动到较低的值，VSSM为高，但是MD1能限制VSSM上升，保持为某一电压。这样保持足够低的电压来保持存储的数据。</strong></p>
<p>图8展示了MOSFET制造的阈值电压Vth和VSSM电压的对比。横轴展示了阈值电压Vth设计的理想值和生产制造的差异，受工艺变化而变化。当制造晶体管的阈值电压Vth低，leakage current高，VSSM 电压必须为高来减小leakage current。当制造晶体管为高，leakage current 为低，VSSM电压需要保持低来确保SRAM的retention 稳定性。</p>
<p><img src="https://i.loli.net/2020/02/28/qeHMDoxYJZLtTGN.png" alt="memory4.8.png"></p>
<p>Fig.8 VSSM voltage when Vth is changed</p>
<p>虚线描绘了满足leakage 目标且最大化cell 稳定性的理想情况。如果MOSFET为worst-leakage 器件，MOSFET的阈值电压Vth低于设计值0.1V，VSSM需要高出0.3V来满足leakage目标。</p>
<p><strong>如果voltage controller仅有power switch和diode组成，VSSM电压如图中（a）线所示</strong>，能满足leakage 目标，但是memory cell的稳定性降低。</p>
<p><strong>如果voltage controller PLVC1由constant-voltage source 电路构成，VSSM电压如图中（b）线所示</strong>，能满足leakage 目标，且稳定性要好于线（a），但是memory cell的稳定性仍然低。</p>
<p>因此，<strong>使用三种类型的MOSFETs，MS1，MD1和MR1，作为voltage controller，VSSM电压（图8中粗线）趋近于理想值</strong>。这些值能满足leakage目标，且保持了更高的稳定性。PLVC1能同时满足leakage目标且保持SRAM高的稳定性。</p>
<p><img src="https://i.loli.net/2020/02/28/GkUdsolePiMtHc3.png" alt="memory4.9.png">Fig.9 Effect of leakage reduction in1-Mbit leakage-worst embedded SRAM</p>
<p>在图9中，陈述了1-Mbit SRAM（图8） 的leakage current。使用leakage降低技术，leakage current能减少大约90%。在图10中给出了130nm SRAM 芯片模型的特征和照片信息。</p>
<p><img src="https://i.loli.net/2020/02/28/d4pgR9kxEJUic1j.jpg" alt="memory4.10.png">Fig. 10 Photograph and features of theprototype chip</p>
<blockquote>
<p><em>Ref</em>*：*<em>Low Power and Reliable SRAM memory Cell and Array Design</em></p>
</blockquote>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>Memory</tag>
        <tag>SRAM</tag>
      </tags>
  </entry>
  <entry>
    <title>SRAM leakage current</title>
    <url>/2020/2020-02-28-SRAM-leakage-current/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>01.Leakage Currents in an SRAM of Conventional Design；</em></p>
<p><em>02.Gate-Tunnel Leakage and GIDL Currents</em></p>
<a id="more"></a>
<p>DRAM有较低的待机功耗，但是需要刷新操作，而SRAM则能静态的保存数据，不需要类似于刷新这样的特殊操作。因此，对于手机或移动设备中集成的SRAM芯片，我们很容易对其进行控制。此外，由于SRAM的制造工艺和CMOS工艺一样，例如移动蜂窝电话等中的应用处理器也使用SRAM作为集成的存储器。</p>
<p>随着MOS工艺的进步，近阈值泄漏电流（subthreshold leakage current）中会增加<strong>gate-oxide tunnel leakage</strong>和<strong>gate-induced drain leakage（GIDL）currents</strong>，成为主要的泄漏电流，增加的泄漏电流同时也增加了整个SRAM cell的静态漏电流。本小节将描述SRAM array的基本泄漏功耗。</p>
<h1><em>leakage Currents in Conventional Design</em></h1>
<p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="https://i.loli.net/2020/02/28/zYtK3kj5GyNTQ6u.png" alt="memory3.1.png"></p>
<p>Fig.1 Leakage currents in a technologically advanced nMOS device</p>
<p>关于工艺进步而造成泄漏电流增加的问题，图1展示了nMos晶体管在工艺上进步产生的4种主要泄漏电流。<strong>包括gate-oxide tunnel leakage，GIDL，junction tunnel leakage以及subthreshold leakage currents.</strong></p>
<p><strong>Subthreshold leakage是当gate为off状态时，由drain到source的沟道泄漏电流，这种状态造成了在沟道区域的微弱反型层。</strong></p>
<p><img src="https://i.loli.net/2020/02/28/qmrVH6kYvJ3T175.png" alt="memory3.2.png"></p>
<p>Fig.2 Standby leakagecurrents in an advanced technology SRAM cell of conventional design</p>
<p>图2中描述了随着工艺进步，使用传统设计方式的SRAM cell中的主要泄漏电流。在传统设计方式中，bit lines（BT，BB）和power line（VDDI）为1.5v，word line 和VSS 为0v。</p>
<p>在整个cell中，<strong>2个gate-tunnel leakage currents，5个GIDL currents和3个subthreshold leakage currents</strong> 组成了主要的漏电流**。**</p>
<p><strong>使用高阈值电压的MOS器件能够直接有效的减少subthreshold leakage currents ，虽然存储单元的读电流也会减小。</strong></p>
<p><strong>然而，通过简单的改变器件结构很难去减小tunnel leakage 和GIDL currents.</strong></p>
<h1><em>Gate-Tunnel Leakage and GIDL Currents</em></h1>
<p>这小节描述了gate-tunnel leakage 和GIDL currents。在图3中给出了<strong>gate-tunnel leakage current 随着栅压（gate voltage） 变化的曲线</strong>，同时<strong>栅氧化层厚度（Tox）作为一个参变量对比分析</strong>。</p>
<p><strong>Tox 每增长2-°A，gate-tunnel leakagecurrent 会增长十倍</strong>。随着工艺的进步，这种电流成为了泄漏电流的主要组成。</p>
<p>另一方面，<strong>栅电流随着栅压减小而减小，减小电压0.5v（从1.5到1.0v）能减小这种泄漏电流的95%</strong>。这是因为tunnel leakage current能随着栅氧化层的电场强度变化而简单的减小。</p>
<p><img src="https://i.loli.net/2020/02/28/KRAyngmhox23SPE.png" alt="memory3.3.png"></p>
<p>Fig.3 Gate-tunnel leakage current as a function of gate voltage with the thickness ofthe gate oxide (Tox) varied as a parameter</p>
<p>图4描述了漏端电流由栅电压（VG）作用的电流曲线。<strong>实线</strong>是漏端电压（VD）为1.0V时的漏端电流曲线，<strong>虚线</strong>为1.5v时漏端电流曲线。当<strong>VG大于0v</strong>时，<strong>subthreshold leakage currents 占主导地位</strong>。当<strong>VG小于0V</strong>时**，GIDL currents 占主导地位**。</p>
<p><img src="https://i.loli.net/2020/02/28/7c3LNTH5Jml6xMI.png" alt="memory3.4.png"></p>
<p>Fig.4 GIDL and subthreshold leakage currents</p>
<p><strong>在使用中提升阈值电压</strong>，在VG=0v时subthreshold leakage currents 相比于GIDL current的强度是可以忽略的。</p>
<p><strong>GIDL current（IGIDL）对于电场强度F非常敏感</strong>。GIDL current 对数曲线线性反比于栅压，栅压直接影响栅氧化层下的电场强度。GIDL current的大小由栅和漏的压差（VGD）决定，VGD由1.5减小到1.0v，电场强度减小，在器件中the GIDL current减小大约90%。</p>
<p>如果**阈值电压很低，**主要的泄漏电流是subthreshold leakage current。通过应用negative VGS，或者negativeVBB back-body bias voltage可以减小subthreshold leakage。具体实现电路和SRAM芯片架构下一期再接着介绍<sup>_</sup></p>
<blockquote>
<p>Ref:Low power and reliable SRAM memory cell and array design[M]. Springer Science &amp; Business Media, 2011.</p>
</blockquote>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>RTL编码中考虑面积</title>
    <url>/2020/2020-02-22-RTL%E7%BC%96%E7%A0%81%E4%B8%AD%E8%80%83%E8%99%91%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>减少设计面积，意味着成本降低、功耗降低。特别是对于FPGA的设计，直接决定着FPGA的选型。</p>
<p>为了减少设计面积，首先得估算设计使用资源的数量，例如触发器、加法器、乘法器等。其中，触发器的数量由功能决定，很难减少，其面积也比较好估计。因此，RTL设计中的组合逻辑，对应的各种操作符在使用的时候应该加以重视。例如，加减法、乘除法以及条件语句中的比较运算。</p>
<a id="more"></a> 
<h2 id="RTL编码中考虑面积"><a class="header-anchor" href="#RTL编码中考虑面积"></a>RTL编码中考虑面积</h2>
<p>如以下实例中，替换判断语句后，实现了1bit逻辑门省掉了一个6bit的比较器。</p>
<p>对于一些定值的数据，类似操作都可以如此考虑RTL设计来节省面积。</p>
<p><img src="https://i.loli.net/2020/02/27/RuKsTDMYajIzV5g.png" alt="RTL3.1.png"></p>
<p>如果，必须使用复杂的运算符，则应考虑是否可以资源共享。尽管电路逻辑综合工具也会在综合的过程中采用资源共享的方法进行优化，但是，综合器的策略是有限的，因此，在编写RTL的时候，应该尽量考虑共享，而不是把这项工作完全留给综合工具。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(y1&gt;a+b+q)</span><br><span class="line">    statement1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y2&gt;a+b+r)</span><br><span class="line">    statement2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y3&gt;a+b+s)</span><br></pre></td></tr></table></figure>
<p>可以将a+b的值sum进行资源共享修改为以下所示，减少了两个不必要的加法器。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">sum&lt;=a+b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y1&gt;sum+q)</span><br><span class="line">    statemnet1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y2&gt;sum+r)</span><br><span class="line">    statement2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y3&gt;sum+s)</span><br></pre></td></tr></table></figure>
<p>除了操作符以外，我们仍需注意多比特数据的使用，其会占用乘倍的资源，应该分析信号的所有比特位是否都需要参与操作，如果不是，咋可以只对需要的部分进行操作。</p>
<p>例如：实现加32的操作</p>
<p><code>addr &lt;= addr + 32;</code> 更换为 <code>{ addr[7:5] &lt;= addr[7:5] + 1; addr[4:0] &lt;= addr[4:0] + 0}</code></p>
<h2 id="RTL编码中考虑功耗"><a class="header-anchor" href="#RTL编码中考虑功耗"></a>RTL编码中考虑功耗</h2>
<hr>
<p>动态功耗的计算公式可以表述为：</p>
<p><img src="https://i.loli.net/2020/02/27/snAGku5yjdZ2D8w.png" alt="RTL3.2.png"></p>
<p>在RTL设计，负载电容和工作电压是无法改变的，主要尽量降低电路的反转频率。</p>
<p><img src="https://i.loli.net/2020/02/27/nkd53GgPFe8xwsH.png" alt="RTL3.3.png"></p>
<p>主要措施：</p>
<p>（1）门控时钟，门控时钟是电路设计最常用也是最有效的方法，在逻辑综合阶段可以让综合工具自行插入。</p>
<p>（2）增加使能信号，使得部分电路只有在需要工作时才工作；</p>
<p>（3）对芯片各个模块进行控制，在需要工作时才工作；</p>
<p>（4）除了有用信号和时钟的翻转会消耗功耗，组合逻辑产生的毛刺也会大量消耗功耗。但是，毛刺在设计中无法避免，因此，只有尽量减少毛刺在电路中的传播，才可以减少功耗。即，在设计中，尽量把产生毛刺的电路放在传播路径的最后。另外，可以使用一些减少毛刺的技术。</p>
<p>（5）对于有限状态机，可以通过低功耗编码来减少电路的翻转。</p>
<p>总的来说，使用这些技术时，应首先考虑全局的功耗控制。</p>
<p>然后再RTL编码中，注意消耗功率较多的电路，如状态机、译码器、多路选择器等。</p>
<p>最后，在综合中，使用门控时钟和其他减少功耗的优化技术。</p>
<p>这里要注意下门控时钟和增加使能控制的区别。增加使能仅仅是使得电路的信号不在翻转，但是时钟每个周期还会继续翻转。而门控时钟则是直接关掉时钟，这种方法效果更好。</p>
<h2 id="RTL中考虑布线问题"><a class="header-anchor" href="#RTL中考虑布线问题"></a>RTL中考虑布线问题</h2>
<hr>
<p>布线（routing），旨在根据门级网表的描述实现各个单元的连接。布线是否能够顺利布通的最关键因素是布局（placement）。但是，即使最好的布局工具，还是可能出现无法布通的情况。这种情况下就需要修改RTL级设计。</p>
<p>因此，如果可以在RTL编码 阶段考虑代码可能对布线产生的影响，就可能避免最后出现无法布通的情况。</p>
<p>热点：指设计中的功能需要在一个面积内占用大量的布线资源</p>
<p><img src="https://i.loli.net/2020/02/27/UaJBPsR8zkMGrjX.png" alt="RTL3.4.png"></p>
<p>热点产生的原因，主要是RTL编码时使用了特定的结构，如很大的MUX。如果设计中的却是需要采用较大的MUX，可将MUX分级为多级较小的MUX。</p>
<blockquote>
<p>参考：<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>RTL编码中考虑延时</title>
    <url>/2020/2020-02-18-RTL%E7%BC%96%E7%A0%81%E4%B8%AD%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>列举了5个实例。</p>
<a id="more"></a>
<h1>示例1：</h1>
<p>假设b信号的延迟较大，到来较晚，那么电路应如何修改？</p>
<p>分析代码可知，当满足条<code>sel[1]&amp;~(sel[2]|sel[3])</code>时，输出z=b。因此我们不可简单的移动<code>if(sel[1]) z=b;</code>语句的位置，否则会改变电路的功能。</p>
<p>RTL代码：</p>
<p><img src="https://i.loli.net/2020/02/27/nXhmOilRxcoPV7g.png" alt="RTL2.1.png"></p>
<p>电路结构：</p>
<p><img src="https://i.loli.net/2020/02/27/cyNhX6ZjsWE74vp.png" alt="RTL2.2.png"></p>
<p>我们做如下修改：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @（*）<span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">0</span>]) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">2</span>]) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">3</span>]) z = d;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">1</span>] &amp; ~(sel[<span class="number">2</span>] | sel[<span class="number">3</span>]))</span><br><span class="line">        z = b_is_late;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>修改后电路结构为：</p>
<p><img src="https://i.loli.net/2020/02/27/jDWPRmNnOucexqs.png" alt="RTL2.3.png"></p>
<h1>示例2：</h1>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> single_if_late(A,C,CTRL_is_late_arriving,Z);</span><br><span class="line"><span class="keyword">input</span> [<span class="number">6</span>:<span class="number">1</span>]A;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">5</span>:<span class="number">1</span>]C;</span><br><span class="line"><span class="keyword">input</span> CTRL_is_late_arriving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Z;</span><br><span class="line"><span class="keyword">always</span> @(A <span class="keyword">or</span> C <span class="keyword">or</span> CTRL_is_late_arriving)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">1</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        Z = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">2</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">3</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        z = A[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">4</span>] == <span class="number">1'b1</span> &amp;&amp; CTRL_is_late_arriving == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">5</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Z = A[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> single_if_improved(A,C,CTRL_is_late_arriving,Z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">6</span>:<span class="number">1</span>]A;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">5</span>:<span class="number">1</span>]C;</span><br><span class="line"><span class="keyword">input</span> CTRL_is_late_arriving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Z,Z1;</span><br><span class="line"><span class="keyword">wire</span> Z2,prev_cond;</span><br><span class="line"><span class="keyword">always</span> @(A <span class="keyword">or</span> C) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">1</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        Z1 = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">2</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z1 = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">3</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        z1 = A[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">5</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z1 = A[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Z1 = A[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> Z2 = A[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">assign</span> prev_cond = (C[<span class="number">1</span>]==<span class="number">1'b1</span>)||(C[<span class="number">2</span>]==<span class="number">1'b0</span>)||(C[<span class="number">3</span>]==<span class="number">1'b1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(C <span class="keyword">or</span> prev_cond <span class="keyword">or</span> CTRL_is_late_arriving <span class="keyword">or</span> Z1 <span class="keyword">or</span> Z2) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>((C[<span class="number">4</span>]==<span class="number">1'b1</span>)&amp;&amp;(CTRL_is_late_arriving==<span class="number">1'b0</span>))</span><br><span class="line">        <span class="keyword">if</span>(prev_cond) Z = Z1;</span><br><span class="line">        <span class="keyword">else</span> Z = Z2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Z = Z1;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>电路结构：</p>
<p><img src="https://i.loli.net/2020/02/27/fTqJLkVlQX9Age1.png" alt="RTL2.4.png"></p>
<h1>示例3：</h1>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> case_in_if_01(A,DATA_is_late_arriving,C,sel,Z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">8</span>:<span class="number">1</span>]A;</span><br><span class="line"><span class="keyword">input</span> DATA_is_late_arriving;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>]sel;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">5</span>:<span class="number">1</span>]C;</span><br><span class="line"></span><br><span class="line">ouput Z;</span><br><span class="line"><span class="keyword">reg</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> C <span class="keyword">or</span> A <span class="keyword">or</span> DATA_is_late_arriving)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">1</span>])</span><br><span class="line">        Z = A[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">2</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">3</span>])</span><br><span class="line">        Z = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="number">3'b010</span>: Z = A[<span class="number">8</span>];</span><br><span class="line">            <span class="number">3'b011</span>: Z = DATA_is_late_arriving;</span><br><span class="line">            <span class="number">3'b101</span>: Z = A[<span class="number">7</span>];</span><br><span class="line">            <span class="number">3'b110</span>: Z = A[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">default</span>: Z = A[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">5</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> Z = A[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>对应的电路结构：</p>
<p><img src="https://i.loli.net/2020/02/27/Qoi35Jl1fr8ZmuV.png" alt="RTL2.5.png"></p>
<p>修改后：</p>
<p><img src="https://i.loli.net/2020/02/27/KJmbBRsLtdWIEA4.png" alt="RTL2.6.png"></p>
<h1>示例4：</h1>
<p>信号CONTROL到达时间较晚，如何修改能够提高电路性能？</p>
<p><img src="https://i.loli.net/2020/02/27/1TQw4BDJhEOeVgY.png" alt="RTL2.7.png"></p>
<p>如下修改，过复制数据路径，将CONTROL信号放到最后，通过先加后选的方式，改善选择信号的延时。</p>
<p><img src="https://i.loli.net/2020/02/27/B3xHm8nwjpZYi2g.png" alt="RTL2.8.png"></p>
<p>调整后的代码：</p>
<p><img src="https://i.loli.net/2020/02/27/OPiCJxWTQ3HsfLl.png" alt="RTL2.9.png"></p>
<h1>范例5：</h1>
<p>假设A信号到来较晚，如何修改能够提高电路性能？</p>
<p><img src="https://i.loli.net/2020/02/27/vMROrbDt7xCAVyu.png" alt="RTL2.10.png"></p>
<p>修改方法：</p>
<p>通过调整A信号的计算顺序，是信号A路上减少了一个加法器。</p>
<p><img src="https://i.loli.net/2020/02/27/1jtPVSlyrZhscMD.png" alt="RTL2.11.png"></p>
<blockquote>
<p>参考：<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>SRAM_cell电学稳定性分析</title>
    <url>/2020/2020-02-15-SRAM_cell%E7%94%B5%E5%AD%A6%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>在SRAM中，读写操作是最基本的，为了保证读写功能可以正常实现，我们需要分开来分析测试读写操作的稳定性，本文便详细阐释了SRAM读写操作的电学稳定性。</em></p>
<a id="more"></a>
<h3 id="Read-and-Write-Operatioins"><a class="header-anchor" href="#Read-and-Write-Operatioins"></a><strong>Read and Write Operatioins</strong></h3>
<hr>
<p><img src="https://i.loli.net/2020/02/27/zami75tvbgGkSjd.png" alt="memory2.1.png"></p>
<p>Fig.1 SRAM memory cell<br>
图1为CMOS 6-T SRAM电路图，图2为其读写操作波形。</p>
<p><img src="https://i.loli.net/2020/02/27/hypWa23on9Y6SUT.jpg" alt="memory2.2.png"></p>
<p>Fig.2 Fundamental waveform of SRAM operation</p>
<p>**当写****入数据“0”(W“0”)**时，word line(WL)被激活，bit line根据输入数据值被驱动到“H”和“L”状态。存储节点的电压发生翻转，输入数据写入到数据存储节点中。</p>
<p>**当从ce****ll中读“0”(R“0”)**时，所有bit line被预充为“H”，激活WL。原先保存在数据节点的数据使bit lines出现电压差。电压差通过灵敏放大器(sense amplifier)放大，保持的数据(retained data)被读出。</p>
<p>**当写入数据“1”到cell中，****且写入失败(W “1” write failure case)**时，存储节点(N0/N1)的电压没有翻转，正确的数据没有写入cell中。在下一个读周期，不正确的数据“0”被读出。</p>
<p>**当读数据“1”，<strong><strong>且读出失败(R1 read failure case</strong></strong>)**时，存储节点的电压(N0/N1)发生翻转，存储节点的保持数据(retained data)被破坏。</p>
<p>图3为SRAM memory保持数据情形，存储节点N0和N1，保持相反的状态，“H”和“L”。word line 为“L”。</p>
<p><img src="https://i.loli.net/2020/02/27/ZR5cD8Ar6dQg4kG.png" alt="memory2.3.png"></p>
<p>Fig.3 SRAM cell condition during data retention</p>
<p>如下图4所示，Memory cell读过程中，右边的节点N1，状态为&quot;H&quot;，左边的节点状态为&quot;L&quot;。在读之前，bit lines被预充电到&quot;H&quot;状态。读的过程中，word lines变为&quot;H&quot;状态，存取管(access MOSs)导通打开。读cell电流Iread从access MOS到“L”-state的存储节点流动，对预充的bit line放电。</p>
<p><img src="https://i.loli.net/2020/02/27/M3QP6qGIwLU9YgH.png" alt="memory2.4.png"></p>
<p>Fig.4 Read operation of SRAM cell</p>
<p>图5a电压波形是SRAM cell在正常读数据的过程中，每个存储节点的电压变化。正常读数据时，存储节点的电压不会发生翻转。图5b为memory cell正常操作的butterfly cruves，用来评估静态噪声裕量(SNM)。两条线之间有两个密闭空隙（space），意味着SRAM读操作的SNM是足够的。</p>
<p><img src="https://i.loli.net/2020/02/27/hCbrwNcd1UKqRvm.png" alt="memory2.5.png"></p>
<p>Fig.5 Voltage waveforms and butterfly curves during normal read operation.<br>
(a) SRAM cell nodes during normal read operation.<br>
(b) Butterfly curves to estimate SNM</p>
<p><strong>在读操作期间，由于access MOS和driver MOS之间的电阻分压</strong>，存储节点的“L&quot;-state被提升。<strong>如果存储节点电压“L”-state的提升值超过了由driver MOS,DR1和loadMOS，LD1组成的反相器的逻辑中点电压，保持数据将翻转</strong>**，被破坏(6a)**。这种情况就是memory cell读失败。图6b是memory cell读数据失败对应的butterfly curves，两条曲线之间只有一个空隙，SRAM能正常读的SNM是不够的。</p>
<p><img src="https://i.loli.net/2020/02/27/YmZqEtu4s8oUaxd.png" alt="memory2.6.png"></p>
<p>Fig.6 Voltage waveforms and butterfly curves during failure read operation.<br>
(a) SRAM cell nodes during failureread operation.<br>
(b) Butterfly curves to estimate SNM</p>
<p><img src="https://i.loli.net/2020/02/27/qJ4Bnw86Dpi1TRN.png" alt="memory2.7.png"></p>
<p>Fig.7 Write operation of SRAM cell</p>
<p>关于写操作，如图7，在写之前，左边存储节点N0是“H” state，右边存储节点N1是“L” state。当要写的数据到达bit lines时，“H” state存储节点经过access MOS放电，写操作cell电流Iwrite,在图中用实线箭头标出。当“H”电位节点被放电至“L”电位时，节点的电压此时发生翻转，写操作完成(图8)。</p>
<p><strong>在写的过程中，load MOS通过上拉电流Ipullup充电</strong>，如图3.7中虚线箭头所示。因此，<strong>如果load MOS充电的电流比access MOS放电电流大的话，存储节点“H”电位不会放电，节点电压不发生翻转，写操作失败(图9)</strong>。</p>
<p><img src="https://i.loli.net/2020/02/27/rtyBeKJo1u25UgE.png" alt="memory2.8.png"></p>
<p>Fig.8 SRAM cell nodes during normal write operation</p>
<p><img src="https://i.loli.net/2020/02/27/CHF6EyRiSsUorMx.png" alt="memory2.9.png"></p>
<p>Fig.9 SRAM cell nodes during failure write operation</p>
<h3 id="Sum"><a class="header-anchor" href="#Sum"></a><strong>Sum</strong></h3>
<hr>
<p><strong>在SRAM cell 中，加强读操作和写操作稳定性的设计方法是一个矛盾的关系</strong>。例如，在表1中促使读操作和写操作更稳定的方法。所以，<strong>很难同时提高读和写操作的稳定性</strong>。在所有的130nm之前的传统制造工艺中，在SRAM cell中有更大的电压工作空间，可以同时保证稳定性，不会出问题。在更近的制造工艺中，随着MOSFETs中Vth变化(variation)，电压工作空间(operation margin)减小，SRAM cell中MOSFET电流随着Vth变化而波动(fluctuated)。</p>
<p>除此之外，Vth variations会破坏在读和写操作期间MOSFET电流的平衡。因此，在SRAM cell设计阶段，最大化SRAM cell的operatingmargin，包括读和写的margin是必不可少的。Vth是MOSFET的一个很好的参数表征，它几乎完全可以指示晶体管的性能。</p>
<p>Table.1 Drivability change to enhancestability of each operation</p>
<p><img src="https://i.loli.net/2020/02/27/9fPUMrCs7QpLxA6.png" alt="memory2.10.png"></p>
<p>为了实现最大化的operating-margins，需要更准确的SRAM operating margins，在本书第3章中，对于受MOSFET Vth variation而影响的SRAM operating margins分析做了进一步描述，这里不再细说。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>SRAM 基础</title>
    <url>/2020/2020-02-12-SRAM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>“</strong> 介绍SRAM基本存储单元，也分析了其设计和读写过程。<strong>”</strong></p>
<p><em>01.最常见的SRAM cell，the full CMOS 6T 类型；</em></p>
<p><em>02.SRAM的读写过程；</em></p>
<p><em>03.执行读操作时最基本的电学稳定**特性，静态噪声裕量(SNM)</em></p>
<a id="more"></a>
<h3 id="SRAM-CELL"><a class="header-anchor" href="#SRAM-CELL"></a>SRAM CELL</h3>
<hr>
<p>Fig.1 SRAM memory cell</p>
<p>SRAM cell由一个基本的触发器（flip-flop）单元构成，即<strong>两个交叉耦合（cross coupled）的反相器</strong>，于flip-flop的存储结点存储逻辑值“0”或“1”。</p>
<p>最常用的SRAM cell是全部由MOS管构成的6个晶体管构成的互补逻辑电路（full CMOS 6-transistor），就SOC（system-on-chip）设计而言，由于full CMOS 6-T使用的工艺为平面CMOS工艺，便于生成制造，故最常使用。</p>
<p>主要组成：</p>
<p><img src="https://i.loli.net/2020/02/27/nZwstNU3l7X1jk9.png" alt="memory1.1.png"></p>
<p>Fig. 2.1 SRAM cell with the full CMOS 6-transistor (6-T)</p>
<p><strong>两个反相器(load MOSFET(LD0)-driver MOSFET(DR0), LD1-DR)；</strong></p>
<p><strong>两个导通管(access MOSFET AC0, AC1)连接到一对bit line(BT,BB)上，同时，导通管的栅端(gate)连接到word line(WL)；</strong></p>
<p>为构成一个flip-flop，<strong>其中一个反相器的输入和输出端需要分别连接到另一个反相器的输出和输入端，也即是交叉耦合</strong>。</p>
<h3 id="Basic-Operation-of-SRAM-Cell"><a class="header-anchor" href="#Basic-Operation-of-SRAM-Cell"></a>Basic Operation of SRAM Cell</h3>
<hr>
<p>Memory的基本排列构造（array structure）如下图2.2所示，整个memory由nxm位memory cell组成。</p>
<p><img src="https://i.loli.net/2020/02/27/WFMs2twxDJ1IjO9.png" alt="memory1.2.png"></p>
<p>Fig. 2.2 Basic full CMOS cell array structure</p>
<p>SRAM具体某一位cell的确定由横向和纵向上共同选中，横向上由**word line译码器（word decoder）<strong>根据地址数据选择一排word line(WL),纵向上bit line控制电路由</strong>预充电电路（precharge circuit），列选择器（Column multiplexer，MUX），灵敏放大器（sense amplifier ，SA)，输出电路（output FF）和写放大器（write amplifier，SA）**构成。详细的电路结构在图2.3中。</p>
<p><img src="https://i.loli.net/2020/02/27/69DFvj1B7X8oMEm.png" alt="memory1.3.png"></p>
<p>Fig. 2.3 Column control circuits consisting of precharge circuit, column multiplexer (mux),sense amplifier (SA), output FF, and write amplifier (WA)</p>
<p>下面介绍SRAM读写操作，如图2.4所示电压波形。<strong>执行读操作需要给bit line先进行预充电（precharge），prechage电路平衡提升bit line的电位至VDD。****随后，word line置高，导通管打开，预先存储于存储节点的数据使cell产生一个小的电压变化（ΔVS）</strong>。</p>
<p><img src="https://i.loli.net/2020/02/27/zaXEm61eDb2NOdR.png" alt="memory1.4.png"></p>
<p>Fig. 2.4 Basic voltage waveform in read and write operation</p>
<p>如果存储的数据为“1”，cell存储节点N0是低电压，N1是高电压。因为DR1没有打开，另一条bit line BB保持平衡时的电压，而BT的电压值则会减小ΔVS 。</p>
<p>通过打开Column-select line for read(YSR)信号，由bit line构成的差分信号传输到灵敏放大器（sense amplifier）的输入端(ST/SB)，经放大后又由output FF锁存输出。如果存储的数据为“0”，与此相似，只不过将会是bit line BB的电压减少。</p>
<p><strong>执行写操作，同样也需要打开word line，在打开word line之前，将bit line电压平衡到VDD，由数据输入端过来的输入数据Din经由write amplifier（WA）传输至bit line</strong>。不同于读操作的是此时column 的选择由column-select signal for write (YSW)来控制。</p>
<p>Bit line电压变化后，使存储节点（N1，N2）的电压翻转，从而写入数据。最后，写操作完成时word line关闭。</p>
<h3 id="Electrical-Stability-at-Read-Operation-Static-Noise-Margin-and-β-Ratio"><a class="header-anchor" href="#Electrical-Stability-at-Read-Operation-Static-Noise-Margin-and-β-Ratio"></a>Electrical Stability at Read Operation:Static Noise Margin and β Ratio</h3>
<hr>
<p><strong>在正常读取数据模式下</strong>，假设node N0处于低电平，node N1处于高电平，字线被激活后，读电流（read current）由BT至N0流动，因此N0的电压会上升ΔVN（图2.4）。</p>
<p><strong>不正常读取操作时</strong>，ΔVN大于DR1的阈值电压（Vth），DR1打开随之N1的电压减小，又导致N0的电压增大，最后致使cell翻转。</p>
<p>因此我们需要通过设计来避免出现不正常的读操作，其中一个重要的衡量稳定性的参数便是静态噪声裕量（SNM）。<strong>SNM参数表征了在读操作期间，cell 出现翻转的电压裕量</strong>。为评估SNM，将word line 和一对bit line连接到VDD（图2.5）。</p>
<p>按如下方式进行仿真分析：</p>
<p>1.N0的电压由0V增加到VDD，同时测量N1的电压，绘制N1-N0的关系；</p>
<p>2.N1的电压由0V增加到VDD，同时测量N0的电压，绘制N0-N1的关系；</p>
<p>3.在曲线A和曲线B（或曲线C和D）中画出最大正方形。方形中较小那个的对角线就是SNM。</p>
<p><img src="https://i.loli.net/2020/02/27/fikUnxgZJH63MQC.png" alt="memory1.5.png"></p>
<p>Fig. 2.5 Connections of the word line and a pair of bit lines to estimate the SNM</p>
<p>如图2.6所示，曲线A和曲线B被称作蝶形曲线“butterfly curb”，图中列出了VDD=0.6V和1.1V的情况，SRAM的工作电压越低，静态噪声裕量SNM越小。</p>
<p><strong>蝶形曲线的不对称性受存储单元MOS管的阈值电压（Vth）变动影响，变化（variation）增加不对称性增加，导致SNM减小</strong>。</p>
<p>Driver MOSFET的阈值电压（Vth）较低，会减小SNM。Driver MOS和access MOS的栅宽之比称作比例因子β。通过增加driver MOS的电流，减小access MOS的电流，从而限制了N0电压的上升值ΔVN ，<strong>因此β增大，SNM增大</strong>。一般情况下，SRAM cell中，比率β大于1.5。</p>
<p><img src="https://i.loli.net/2020/02/27/x5yhRZagcfiNmSC.png" alt="memory1.6.png"></p>
<p>Fig. 2.6 Butterfly curbs are shown at VDD 0.6V and 1.1V</p>
<p>因为full CMOS 6-T memory 能在静态工作状态下保存数据，不需要额外的动态刷新。在读的时候，因为有电压相反的bit line信号配合输出给差分放大器，能在较短时间内获取数据。因此，SRAM在cache memory，mobile phone等等都都有应用，但SRAM cell 也需要在standby mode 下降低其保持数据所产生的功耗。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>CMOS反相器之动态特性</title>
    <url>/2020/2020-02-10-CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%B9%8B%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>CMOS反相器的性能：动态特性</strong></p>
<hr>
<p>CMOS反相器的传播延时取决于它分别通过PMOS和NMOS管充放电负载电容C<sub>L</sub>所需要的时间。使C<sub>L</sub>尽可能小是实现高性能CMOS电路的关键。</p>
<a id="more"></a>
<h1>电容值分类</h1>
<ul>
<li>栅漏电容C<sub>gd12</sub></li>
<li>扩散电容C<sub>db1</sub>和C<sub>db2</sub></li>
<li>连线电容C<sub>W</sub></li>
<li>扇出的栅电容C<sub>g3</sub>和C<sub>g4</sub></li>
</ul>
<p><img src="https://i.loli.net/2020/02/27/uP8fmyGnhQa79FV.png" alt="CMOS2.1.png"></p>
<h1>传播延时：一阶分析</h1>
<p>等效导通电阻R<sub>eq</sub>，反相器的总传播延时：t<sub>p</sub> = （t<sub>pHL</sub> + t<sub>pLH</sub>)/2，其中：<br>
​	t<sub>pHL</sub>= 0.69 R<sub>eqn</sub>C<sub>L</sub><br>
​	t<sub>pLH</sub>= 0.69 R<sub>eqp</sub>C<sub>L</sub></p>
<p><strong>减小门传播延时：</strong></p>
<ul>
<li>
<p>减小C<sub>L</sub>：负载电容由三个主要部分组成：内部的扩散电容、互连线电容和扇出电容。通过细致的版图设计有助于减少扩散电容和互连线电容</p>
</li>
<li>
<p>增加晶体管的W/L比：可以减小等效电阻，是最有力和最有效的性能优化工具。</p>
<p><font color="#dd0000">同时增加晶体管尺寸也会增加扩散电容，因而增加C<sub>L</sub>，当本征电容超过由连线和扇出行成的外部负载时，增加门的尺寸不再对减少延时有帮助。</font><br>
<font color="#dd0000">较宽的晶体管具有较大的栅电容，增加了驱动门的扇出系数，从而反过来影响它的速度。</font></p>
</li>
<li>
<p>提高VDD：牺牲功耗来换取性能</p>
</li>
</ul>
<h1>从设计角度考虑传播延时</h1>
<p><strong>NMOS和PMOS的比</strong><br>
通常要求PMOS与NMOS的宽度比在3~3.5之间，使得设计反相器具有对称的VTC，并使得t<sub>pHL</sub> =t<sub>pLH</sub>。但如果对称性和噪声容限不是主要的考虑因素，可通过减小PMOS器件的宽度来加快反相器的速度。原因是，是PMOS较宽可以改善反相器的t<sub>pLH</sub> ，但它也由于产生较大的寄生电通而使tpHL 变差。</p>
<p><strong>考虑性能时反相器的尺寸的确定</strong></p>
<p>负载电容划分为：C<sub>L</sub> = C<sub>int</sub> + C<sub>ext</sub>，其中 C<sub>int</sub> 即本征输出电容， C<sub>ext</sub>是外部负载电容，来自扇出和导线电容。</p>
<p><img src="https://i.loli.net/2020/02/27/la5JwvcOIGQeSk8.png" alt="CMOS2.3.png"></p>
<p>Leads two important conclusions:</p>
<ul>
<li>反相器的本征延时tp0与门的尺寸无关，而只取决于工艺及方相器的版图；</li>
<li>使S无穷大将达到最大可能的性能改善，使延时减小到只有本征延时值。</li>
</ul>
<p><strong>确定反相器链的尺寸</strong></p>
<p>每一个反相器的最优尺寸是与它相邻的前后两个反相器尺寸的几何平均数，即每个反相器都具有相同的等效扇出，也就具有相同的延时。可以推导出尺寸系数f。</p>
<p><strong>选择一个反相器链的正确级数</strong></p>
<p>简化条件下可以得到最优的级数为N = ln(F)。</p>
<p>选择的扇出值大于最优值并不会过多的影响延时，但能减少所要求的缓冲器级数和实现面积。</p>
<p><strong>输入信号的上升-下降时间</strong></p>
<p>保持门的输入信号的上升时间小于或等于门的传播延时是很有利的。</p>
<p><strong>存在（长）互连线时的延时</strong></p>
<p>当门之间的距离进一步加大之后，互连线的电容和电阻就不容忽略，也使得导线延时在较长导线的总延时中总迅速占据主要地位。（延时表达式中有一个与导线长度呈线性关系和一个成平方关系的部分）</p>
<h1>功耗、能量和能量延时</h1>
<p><strong>动态功耗</strong></p>
<p>反相器门开关过程中，由充放电电容引起的功耗</p>
<p><strong>设计技术</strong><br>
改变器件尺寸并降低电源电压是减小一个逻辑电路能耗的非常有效的方法；<br>
在最优值之外过多地加大晶体管尺寸会付出较大的能量代价。至今许多设计仍普采用这种方法；<br>
考虑能量时的最优尺寸系数小于考虑性能时的最优尺寸系数</p>
<p><strong>直通功耗</strong><br>
由于输入波形的上升和下降时间为零。开关过程中VDD和GND之间在短期内出现一条直流通路，此时NMOS和PMOS同时导通。直接通路电流引起功耗</p>
<p><strong>设计技术</strong><br>
使输出的上升/下降时间大于输入的上升/下降时间可以使短路功耗减到最小；</p>
<p><img src="https://i.loli.net/2020/02/27/yHuY7ReGIPrv31z.png" alt="CMOS2.4.png"></p>
<p>从全局的角度看，应该使所有信号的上升/下降时间保持在一定范围内不变。当负载电容太小时，功耗主要来自于短路电流，对于非常大的负载电容值，功耗主要是电容充电和放电产生。</p>
<p><strong>静态功耗</strong></p>
<p>由于泄漏电流流过位于晶体管源（或漏）与衬底之间的反相偏置的二极管结而形成的静态功耗；晶体管的亚阈值电流。</p>
<p><strong>设计技术</strong></p>
<p>阈值电压的选择代表了在性能和静态功耗之间的权衡取舍。降低电源电压而保持阈值电压不变会造成性能的严重损失，阈值电压的最低值又是由所允许的亚阈值漏电电流的数量所决定的。</p>
<p>通过权衡选择正确的电源值和阈值电压值；</p>
<p>当存在较大静态功耗时，使不工作的模块暂时断电以减少静态功耗。</p>
<p><strong>综合考虑</strong></p>
<p>CMOS反相器的总功耗可以分为三部分的和：</p>
<p><img src="https://i.loli.net/2020/02/27/Ur1CHIhpRgYzEmw.png" alt="CMOS2.2.png"></p>
<p>其中Pdyn为电容功耗，Pdp为直接通路功耗，Pstat为漏电功耗。</p>
<p><strong>功耗—延时积或每次操作的能量损耗</strong></p>
<p>衡量了开关门所需要的能量</p>
<p><strong>能量—延时积</strong></p>
<p>衡量电源电压（即性能）与延时之间的矛盾关系</p>
<h1>小结</h1>
<ul>
<li>静态CMOS反相器，组合了一个上拉PMOS和一个下拉的NMOS，由于PMOS有较低的电流驱动能力，通常使它比NMOS宽。</li>
<li>理想的电压传输特性。逻辑摆幅等于电源电压并且与晶体管尺寸无关。噪声容限接近VDD/2.稳态响应不受扇出的影响。</li>
<li>传播延时主要由充放电负载电容CL所需要的时间决定。一阶近似为，tp=0.69CL((Reqn + Reqp)/2),使负载电容较小是实现高性能电路的最有效手段。</li>
<li>功耗主要由充放电负载电容时消耗的动态功耗决定。功耗与电路的活动性成正比。开关通断期间的直接通路功耗可以通过对信号斜率的仔细修正来限制。静态功耗通常可以忽略，但由于阈值电流的原因可能成为一个主要因素。</li>
<li>工艺尺寸变小是减少一个门的面积、传播延时以及功耗的有效手段。同时降低电源电压，影响更大。</li>
<li>互连线的影响将在总延时和总性能中逐渐占有更大的比例。</li>
</ul>
<p>参考资料：</p>
<blockquote>
<p>Rabaey J M, Chandrakasan A P, Nikolić B. Digital integrated circuits: a design perspective[M]. Upper Saddle River, NJ: Pearson Education, 2003.</p>
</blockquote>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>数字集成电路设计基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog HDL 基础</title>
    <url>/2020/2020-02-09-Verilog%20HDL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Verilog HDL 语言的特点</h1>
<p><strong>互连（connectivity）</strong>：网络数据类型表示结构实体（例如门）之间的物理连接，不能存储值，由驱动器（例如门或连续赋值语句，assign）驱动。常见类型包括wire型和tri型。</p>
<p><strong>并发</strong>（concurrency）：可以有效地描述并行的硬件系统</p>
<p><strong>时间</strong>（time）：定义了绝对和相对的时间度量，可综合操作符具有物理延迟</p>
<p><strong>可综合</strong>：always、if-else、case、assgin</p>
<p><strong>不可综合</strong>：function、for、fork-join、while</p>
<a id="more"></a>
<h1>常见可综合语法与硬件电路的关系</h1>
<h2 id="if-else相关语句的硬件结构映射及优化"><a class="header-anchor" href="#if-else相关语句的硬件结构映射及优化"></a>if-else相关语句的硬件结构映射及优化</h2>
<p>对应的硬件结构是多路选择器（Multiplexing Hardware）</p>
<ul>
<li>需要根据输入约束，小心设计：先“加”后“选”，先“选”后“加”</li>
</ul>
<p><img src="https://i.loli.net/2020/02/27/DCQPkFWzhmJA9SZ.png" alt="RTL1.1.png"></p>
<ul>
<li>
<p>单if语句，无优先级的判断结构</p>
</li>
<li>
<p>多if语句，具有优先级的判断结构</p>
<p>最后一级选择信号具有最高优先权；<br>
具有优先级的多选择结构会消耗组合逻辑</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/27/9tMhjpIADVRfw5W.png" alt="RTL1.2.png"></p>
<h2 id="case相关语句的硬件结构映射及优化"><a class="header-anchor" href="#case相关语句的硬件结构映射及优化"></a>case相关语句的硬件结构映射及优化</h2>
<p>对应的硬件结构是无优先级的判断结构，与单if语句的区别在于各条件互斥，多用于指令译码电路</p>
<h2 id="慎用latch"><a class="header-anchor" href="#慎用latch"></a>慎用latch</h2>
<ul>
<li>
<p>综合器很难解释latch，因此，除非特殊用途，一般避免引入latch。</p>
<p><img src="https://i.loli.net/2020/02/27/6GzFjdIWsUPpKye.png" alt="RTL1.3.png"><br>
latch由电平触发，非同步控制。DFF由时钟边沿触发，同步控制。</p>
</li>
<li>
<p>在使能信号有效时，latch相当于通路，无效时latch保持输出数据的当前值。因此latch容易产生毛刺（glitch），DFF则不易产生毛刺。latch将静态时序分析变得极为复杂。<br>
一般的设计规则是：在绝大多数设计中避免产生latch。latch最大的危害在于不能过滤毛刺，这对于下一级电路是极其危险的，所以只要能用DFF的地方，就不用latch。</p>
</li>
<li>
<p>易引入latch的途径：使用不完备的条件判断语句</p>
</li>
<li>
<p>防止产生非目的性latch的措施：<br>
使用完备的if…else语句<br>
为每个输入条件设计输出操作，为case语句设置default操作<br>
仔细检查综合器生成的报告，latch会以warning的形式报告</p>
</li>
<li>
<p>综合器指令，full-case和parallel-case</p>
<p>Full-case：告诉综合器，当前case结构所列条件已完备</p>
<p>Parallel-case：告诉DC，所有条件互斥，且并行，无优先权</p>
</li>
</ul>
<h2 id="逻辑复制，均衡负载"><a class="header-anchor" href="#逻辑复制，均衡负载"></a>逻辑复制，均衡负载</h2>
<p>通过逻辑复制，降低关键信号的扇出，进而降低该信号的传播延迟，提高电路性能。</p>
<p><img src="https://i.loli.net/2020/02/27/pB7qAltnWrg6vK3.png" alt="RTL1.4.png"></p>
<h2 id="资源共享，减小面积"><a class="header-anchor" href="#资源共享，减小面积"></a>资源共享，减小面积</h2>
<p><img src="https://i.loli.net/2020/02/27/FzgvMmDeUKl6BiT.png" alt="RTL1.5.png"></p>
<h2 id="资源顺序重排，降低传播延时"><a class="header-anchor" href="#资源顺序重排，降低传播延时"></a>资源顺序重排，降低传播延时</h2>
<p><img src="https://i.loli.net/2020/02/27/lXg6WIJ89CjOSPH.png" alt="RTL1.6.png"></p>
<h2 id="同步复位与异步复位"><a class="header-anchor" href="#同步复位与异步复位"></a>同步复位与异步复位</h2>
<h2 id="少用“：？”赋值语句"><a class="header-anchor" href="#少用“：？”赋值语句"></a>少用“：？”赋值语句</h2>
<p>使用always用于逻辑运算，关于assign，仅用于信号连接，难以阅读，且多层嵌套后很难被综合其解释</p>
<h1>可综合风格</h1>
<h2 id="完整的always敏感信号列表"><a class="header-anchor" href="#完整的always敏感信号列表"></a>完整的always敏感信号列表</h2>
<p>所有的组合逻辑或锁存的always结构必须有敏感信号列表。这个敏感信号列表必须包含所有的输入信号</p>
<p><em>原因：综合过程将产生一个取决于除开敏感信号列表中所有其他值的结构，将可能在行为仿真和门级仿真间产生潜在的适配。</em></p>
<h2 id="每个always敏感信号列表对应一个时钟"><a class="header-anchor" href="#每个always敏感信号列表对应一个时钟"></a>每个always敏感信号列表对应一个时钟</h2>
<p>在综合过程中，每个Verilog always敏感信号列表只能对应一个时钟。</p>
<p><em>原因：这是将每一个过程限制在单一寄存器类型的要求。</em></p>
<h2 id="在时序电路中必须使用非阻塞赋值（-），组合逻辑电路必须使用阻塞赋值（-）。"><a class="header-anchor" href="#在时序电路中必须使用非阻塞赋值（-），组合逻辑电路必须使用阻塞赋值（-）。"></a>在时序电路中必须使用非阻塞赋值（&lt;=），组合逻辑电路必须使用阻塞赋值（=）。</h2>
<h1>模块划分</h1>
<h2 id="分开异步逻辑与同步逻辑"><a class="header-anchor" href="#分开异步逻辑与同步逻辑"></a>分开异步逻辑与同步逻辑</h2>
<p>建议分开异步逻辑与同步逻辑</p>
<p><em>原因：避免综合时的问题，简化约束和编码难度。</em></p>
<h2 id="分开控制逻辑和存储器"><a class="header-anchor" href="#分开控制逻辑和存储器"></a>分开控制逻辑和存储器</h2>
<p>建议控制逻辑和存储器逻辑分成独立的模块</p>
<p><em>原因：便于高层的存储器模块的使用和便于重新描述为不同的存储器类型。</em></p>
<blockquote>
<p>参考：<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener" title="芯动力--硬件加速设计方法">芯动力–硬件加速设计方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>CMOS反相器介绍</title>
    <url>/2020/2020-02-08-CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>CMOS设计指标</h1>
<p><strong>设计指标：</strong></p>
<ul>
<li>成本：用复杂性和面积来表示</li>
<li>完整性和稳定性：用静态（即稳态）特性来表示</li>
<li>性能：由动态（即瞬态）响应决定</li>
<li>能量效率：由能耗和功耗决定</li>
</ul>
<a id="more"></a>
<h1>静态CMOS反相器</h1>
<p><strong>特性：</strong></p>
<ul>
<li>输出高电平和低电平分别为VDD和GND。没有阈值损失，通过PMOS传高电平VDD，通过NMOS传低电平GND。</li>
<li>无比逻辑。晶体管的尺寸可采用最小尺寸。</li>
<li>稳态时在输出和VDD或GND之间总存在一条具有有限电阻的通路。具有低输出阻抗。</li>
<li>CMOS反相器的输入电阻极高。由于MOS管的栅实际上是一个绝缘体，因此不去任何DC（直流）输入电流。</li>
<li>无静态功耗。稳态工作情况下电源和地线之间没有直接的通路（即此时输入和输出保持不变）。</li>
</ul>
<p><strong>电压传输特性（VTC）：</strong></p>
<p><img src="https://i.loli.net/2020/02/27/Vx1z9HeK3aXd67o.png" alt="CMOS1.1.png"></p>
<ul>
<li>PMOS的静态特性曲线可由镜像平移得到，观察两种MOS管的VTC曲线可得到CMOS反相器的传输特性<br>
<img src="https://i.loli.net/2020/02/27/1vcobZewWzkRTu3.png" alt="CMOS1.2.png"></li>
<li>瞬态特性，主要由CL决定。CL主要包括NMOS和PMOS的漏扩散电容、连线电容和扇出门的输入电容。</li>
<li>低到高，门的响应时间由通过RP充电电容CL决定，传播延时正比于时间常数RPCL：<br>
快速门设计方法：减小输出电容；减小晶体管导通电阻（加大器件的W/L）</li>
<li>高到低，门的响应时间由电容CL通过电阻Rn对地放电决定，传播延时正比于时间常数RnCL</li>
</ul>
<h1>CMOS反相器稳定性的评估——静态特性</h1>
<p><strong>开关阈值：VM定义为Vin=Vout的点。</strong></p>
<p>一般希望开关阈值VM处于电压摆幅的中点（VDD/2）附近，这样可使高噪声容限和低噪声容限具有相近的值。</p>
<ul>
<li>
<p>设计技术：<br>
为使得噪声容限最大并得到对称的特性，建议使PMOS比NMOS部分宽以均衡晶体管的驱动强度。<br>
<img src="https://i.loli.net/2020/02/27/d63gQvVMnLyRUAG.png" alt="CMOS1.3.png"></p>
</li>
<li>
<p>VM对器件比值的变化不敏感<br>
设计中使PMOS管的宽度小于完全对称时所要求的值是可以接受的</p>
</li>
<li>
<p>改变Wp和Wn比值的影响使VTC的过渡区平移<br>
增加PMOS或NMOS宽度分别使VM移向VDD或GND。这种不对称设计在某些设计中使所期望的。</p>
</li>
</ul>
<p><strong>噪声容限</strong></p>
<ul>
<li>
<p>对VTC曲线做逐段近似简化，得出VIH和VIL，推导出高电平噪声容限和低电平噪声容限：<br>
NMH = VDD - VIH , NML = VIL<br>
<img src="https://i.loli.net/2020/02/27/17zsQ6Tu9HjbrhB.png" alt="CMOS1.4.png"></p>
</li>
<li>
<p>器件参数的变化<br>
静态CMOS反相器对这些变化不敏感，可以在一个很宽的工作条件下工作。</p>
</li>
<li>
<p>降低电源电压（在接近100mV的时候，门的特性变差）<br>
不加区分的降低电源电压虽然对减少能耗有正面影响，但会使门的延时加大；<br>
一旦电源电压和本征电压（阈值电压）变得可以比拟，DC特性对器件参数的变化会变得更加敏感；降低电源电压意味着减小信号摆幅，可以帮助减小内部噪声，但它使设计对并不减小的外部噪声源更加敏感</p>
</li>
</ul>
<p>参考资料：</p>
<blockquote>
<p>Rabaey J M, Chandrakasan A P, Nikolić B. Digital integrated circuits: a design perspective[M]. Upper Saddle River, NJ: Pearson Education, 2003.</p>
</blockquote>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>数字集成电路设计基础</tag>
      </tags>
  </entry>
  <entry>
    <title>sed实例</title>
    <url>/2020/2020-02-07-sed%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>GNU sed实例教程</h1>
<blockquote>
<p>sed (stream editor) is a non-interactive command-line text editor.</p>
</blockquote>
<p>官方的定义是非交互地命令行文本编辑器。而我觉得描述成“行内文本插入、删除、替换的小工具“更容易理解。</p>
<p>说到”行内“，即以一行文本为单位进行处理。sed的工作模式如下图，读入一行文本到内部的buffer，执行处理文本命令，输出到屏幕。然后读入下一行文本，进行下一轮处理。</p>
<a id="more"></a>
<h2 id="sed使用方法"><a class="header-anchor" href="#sed使用方法"></a>sed使用方法</h2>
<p>sed使用格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -option &#39;cmd&#39; file</span><br></pre></td></tr></table></figure>
<p>其中，-option是sed的一些选项，'cmd’是处理文本的命令，如插入、删掉、替换等，file是待处理的文件。</p>
<p>cmd一般用单引号括起来，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;[line num]X[options]&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>line num是指定待处理的单行或几行。如果不指定行号，即为所有行。</li>
<li>X是执行的命令，如a（append）、d（delete）、i（insert）、s（search and replace）等。</li>
<li>options是指某些命令后可以带额外的参数。</li>
</ul>
<h2 id="sed基本用法示例"><a class="header-anchor" href="#sed基本用法示例"></a>sed基本用法示例</h2>
<h6 id="示例一："><a class="header-anchor" href="#示例一："></a>示例一：</h6>
<p>第一行插入日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;1i &#x2F;&#x2F;2019-2-13&#39; rtl.v</span><br></pre></td></tr></table></figure>
<h6 id="示例二："><a class="header-anchor" href="#示例二："></a>示例二：</h6>
<p>删除`timescale 1ns/100ps行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;\x60timescale&#x2F;d&#39;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>`用ASCII码0x60转义。</li>
<li>/xxx/是用正则的方式来指定要处理哪些行，也可以理解成包含xxx的行。</li>
</ol>
<h6 id="示例三："><a class="header-anchor" href="#示例三："></a>示例三：</h6>
<p>endmodule后面加// xxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;endmodule&#x2F;a &#x2F;&#x2F; xxx&#39; rtl.v</span><br></pre></td></tr></table></figure>
<h6 id="示例四："><a class="header-anchor" href="#示例四："></a>示例四：</h6>
<p>把output wire修改成output reg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;output&#x2F;s&#x2F;wire&#x2F;reg&#x2F;&#39; rtl.v</span><br></pre></td></tr></table></figure>
<h6 id="示例五："><a class="header-anchor" href="#示例五："></a>示例五：</h6>
<p>看看analog verilog model文件中有哪些module</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;&#x2F;^module&#x2F;p&#39; ana_v.v</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>-n是取消默认的打印，即仅打印匹配的行。</li>
<li>p是打印命令。</li>
</ol>
<h6 id="示例六："><a class="header-anchor" href="#示例六："></a>示例六：</h6>
<p>把逗号分隔的端口或者变量分成多行书写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;s&#x2F;,&#x2F;,\n&#x2F;g&#39; rtl.v</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>\n是回车符，用来换行</li>
<li>g是指行内替换多次，如果不加g则替换一次。</li>
</ol>
<h6 id="示例七："><a class="header-anchor" href="#示例七："></a>示例七：</h6>
<p>统计rtl的行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;$&#x3D;&#39; rtl.v</span><br></pre></td></tr></table></figure>
<h6 id="示例八："><a class="header-anchor" href="#示例八："></a>示例八：</h6>
<p>把//aa的下一行中的assign加上延时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;\&#x2F;\&#x2F;aa&#x2F;&#123;n;s&#x2F;assign&#x2F;assign #1&#x2F;&#125;&#39; rtl.v</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>n是跳转到下一行，再执行后面的命令。</li>
</ol>
<h2 id="sed高级用法示例"><a class="header-anchor" href="#sed高级用法示例"></a>sed高级用法示例</h2>
<p>sed内部有两个存储空间，模式空间（pattern space）和保持空间（hold space）。模式空间就是上面提到的“行buffer”，而保持空间可以理解为另一个buffer，可以暂存任何临时数据。你可以想像成CPU的两个寄存器，通过类似汇编的指令来操作。</p>
<ul>
<li>g 将hold space中的内容拷贝到pattern space中</li>
<li>G 将hold space中的内容追加到pattern space中</li>
<li>h 将pattern space中的内容拷贝到hold space中</li>
<li>H 将pattern space中的内容追加到hold space中</li>
<li>d 删除multiline pattern中的所有行，并读入下一新行到pattern中</li>
<li>D 删除multiline pattern中的第一行</li>
<li>x 交换保持空间和模式空间的内容</li>
</ul>
<h6 id="示例九："><a class="header-anchor" href="#示例九："></a>示例九：</h6>
<p>删除rtl中的多行注释/* … */</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n script</span><br><span class="line"></span><br><span class="line">     1	&#x2F;\&#x2F;\*&#x2F;!&#123;p;d&#125;</span><br><span class="line">     2	:a</span><br><span class="line">     3	&#x2F;\*\&#x2F;&#x2F;!&#123;N;ba&#125;</span><br><span class="line">     4	s&#x2F;\&#x2F;\*.*\*\&#x2F;&#x2F;&#x2F;</span><br><span class="line">     5	p</span><br><span class="line"></span><br><span class="line">sed -nf script rtl.v</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>第1行，当没有遇到/*的行时，先输出，然后d忽略掉下方的其它sed命令，退出本次处理。只有遇到/*才开执行后续的命令。</li>
<li>第2行，:a设置标签</li>
<li>第3行，如果没有遇到*/，就把内容追加到pattern space</li>
<li>第4行，遇到*/后，执行查找替换，把/* … */删除</li>
<li>第5行，输出删除注释后的rtl</li>
<li>由于sed正则没有非贪婪模式，不然就可以直接全部读到pattern space再用正则。</li>
<li>-f选项是指sed命令写在脚本里，好处是不需要考虑shell的转义，写多个命令时比较方便。</li>
</ol>
<h6 id="示例十："><a class="header-anchor" href="#示例十："></a>示例十：</h6>
<p>交换rtl中的相邻两行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;&#123;h;n;G;p&#125;&#39; rtl.v</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>h把第一行存入hold space</li>
<li>n读入第二行到pattern space（覆盖掉第一行）</li>
<li>G把hold space中的内容追加到pattern space</li>
<li>p输出</li>
</ol>
<blockquote>
<p>《GNU sed, a stream editor 》  version 4.5, 30 March 2018  by Ken Pizzini, Paolo Bonzini  （P85）</p>
</blockquote>
<blockquote>
<p>本文转载自:<a href="http://exasic.com" target="_blank" rel="noopener" title="ExASIC">ExASIC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
