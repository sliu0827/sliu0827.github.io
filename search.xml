<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RTL编码中考虑面积</title>
    <url>/2020/02/22/RTL%E7%BC%96%E7%A0%81%E4%B8%AD%E8%80%83%E8%99%91%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>减少设计面积，意味着成本降低、功耗降低。特别是对于FPGA的设计，直接决定着FPGA的选型。</p>
<p>为了减少设计面积，首先得估算设计使用资源的数量，例如触发器、加法器、乘法器等。其中，触发器的数量由功能决定，很难减少，其面积也比较好估计。因此，RTL设计中的组合逻辑，对应的各种操作符在使用的时候应该加以重视。例如，加减法、乘除法以及条件语句中的比较运算。</p>
<a id="more"></a> 



<h2 id="RTL编码中考虑面积"><a href="#RTL编码中考虑面积" class="headerlink" title="RTL编码中考虑面积"></a>RTL编码中考虑面积</h2><p>如以下实例中，替换判断语句后，实现了1bit逻辑门省掉了一个6bit的比较器。</p>
<p>对于一些定值的数据，类似操作都可以如此考虑RTL设计来节省面积。</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/2.RTL%E8%80%83%E8%99%91%E9%9D%A2%E7%A7%AF/fig1.png" alt="img"></p>
<p>如果，必须使用复杂的运算符，则应考虑是否可以资源共享。尽管电路逻辑综合工具也会在综合的过程中采用资源共享的方法进行优化，但是，综合器的策略是有限的，因此，在编写RTL的时候，应该尽量考虑共享，而不是把这项工作完全留给综合工具。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(y1&gt;a+b+q)</span><br><span class="line">    statement1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y2&gt;a+b+r)</span><br><span class="line">    statement2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y3&gt;a+b+s)</span><br></pre></td></tr></table></figure>



<p>可以将a+b的值sum进行资源共享修改为以下所示，减少了两个不必要的加法器。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">sum&lt;=a+b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y1&gt;sum+q)</span><br><span class="line">    statemnet1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y2&gt;sum+r)</span><br><span class="line">    statement2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y3&gt;sum+s)</span><br></pre></td></tr></table></figure>



<p>除了操作符以外，我们仍需注意多比特数据的使用，其会占用乘倍的资源，应该分析信号的所有比特位是否都需要参与操作，如果不是，咋可以只对需要的部分进行操作。</p>
<p>例如：实现加32的操作</p>
<p><code>addr &lt;= addr + 32;</code> 更换为 <code>{ addr[7:5] &lt;= addr[7:5] + 1; addr[4:0] &lt;= addr[4:0] + 0}</code></p>
<h2 id="RTL编码中考虑功耗"><a href="#RTL编码中考虑功耗" class="headerlink" title="RTL编码中考虑功耗"></a>RTL编码中考虑功耗</h2><hr>
<p>动态功耗的计算公式可以表述为：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/2.RTL%E8%80%83%E8%99%91%E9%9D%A2%E7%A7%AF/fig2.png" alt="img"></p>
<p>在RTL设计，负载电容和工作电压是无法改变的，主要尽量降低电路的反转频率。</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/2.RTL%E8%80%83%E8%99%91%E9%9D%A2%E7%A7%AF/fig3.png" alt="img"></p>
<p>主要措施：</p>
<p>（1）门控时钟，门控时钟是电路设计最常用也是最有效的方法，在逻辑综合阶段可以让综合工具自行插入。</p>
<p>（2）增加使能信号，使得部分电路只有在需要工作时才工作；</p>
<p>（3）对芯片各个模块进行控制，在需要工作时才工作；</p>
<p>（4）除了有用信号和时钟的翻转会消耗功耗，组合逻辑产生的毛刺也会大量消耗功耗。但是，毛刺在设计中无法避免，因此，只有尽量减少毛刺在电路中的传播，才可以减少功耗。即，在设计中，尽量把产生毛刺的电路放在传播路径的最后。另外，可以使用一些减少毛刺的技术。</p>
<p>（5）对于有限状态机，可以通过低功耗编码来减少电路的翻转。</p>
<p>总的来说，使用这些技术时，应首先考虑全局的功耗控制。</p>
<p>然后再RTL编码中，注意消耗功率较多的电路，如状态机、译码器、多路选择器等。</p>
<p>最后，在综合中，使用门控时钟和其他减少功耗的优化技术。</p>
<p>这里要注意下门控时钟和增加使能控制的区别。增加使能仅仅是使得电路的信号不在翻转，但是时钟每个周期还会继续翻转。而门控时钟则是直接关掉时钟，这种方法效果更好。</p>
<h2 id="RTL中考虑布线问题"><a href="#RTL中考虑布线问题" class="headerlink" title="RTL中考虑布线问题"></a>RTL中考虑布线问题</h2><hr>
<p>布线（routing），旨在根据门级网表的描述实现各个单元的连接。布线是否能够顺利布通的最关键因素是布局（placement）。但是，即使最好的布局工具，还是可能出现无法布通的情况。这种情况下就需要修改RTL级设计。</p>
<p>因此，如果可以在RTL编码 阶段考虑代码可能对布线产生的影响，就可能避免最后出现无法布通的情况。</p>
<p>热点：指设计中的功能需要在一个面积内占用大量的布线资源</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/2.RTL%E8%80%83%E8%99%91%E9%9D%A2%E7%A7%AF/fig4.png" alt="img"></p>
<p>热点产生的原因，主要是RTL编码时使用了特定的结构，如很大的MUX。如果设计中的却是需要采用较大的MUX，可将MUX分级为多级较小的MUX。</p>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>RTL编码中考虑延时</title>
    <url>/2020/02/20/2020-02-18-RTL%E7%BC%96%E7%A0%81%E4%B8%AD%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>列举了5个实例。</p>
<a id="more"></a>

<h1 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h1><p>假设b信号的延迟较大，到来较晚，那么电路应如何修改？</p>
<p>分析代码可知，当满足条<code>sel[1]&amp;~(sel[2]|sel[3])</code>时，输出z=b。因此我们不可简单的移动<code>if(sel[1]) z=b;</code>语句的位置，否则会改变电路的功能。</p>
<p>RTL代码：</p>
<img src="https://sliu0827.github.io/source/images/RTL/1.RTL考虑延时/fig1.png" alt="img" style="zoom: 67%;" />

<p>电路结构：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig2.png" alt="img"></p>
<p>我们做如下修改：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @（*）<span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">0</span>]) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">2</span>]) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">3</span>]) z = d;</span><br><span class="line">    <span class="keyword">if</span> (sel[<span class="number">1</span>] &amp; ~(sel[<span class="number">2</span>] | sel[<span class="number">3</span>]))</span><br><span class="line">        z = b_is_late;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>修改后电路结构为：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig3.png" alt="img"></p>
<h1 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h1><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> single_if_late(A,C,CTRL_is_late_arriving,Z);</span><br><span class="line"><span class="keyword">input</span> [<span class="number">6</span>:<span class="number">1</span>]A;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">5</span>:<span class="number">1</span>]C;</span><br><span class="line"><span class="keyword">input</span> CTRL_is_late_arriving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Z;</span><br><span class="line"><span class="keyword">always</span> @(A <span class="keyword">or</span> C <span class="keyword">or</span> CTRL_is_late_arriving)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">1</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        Z = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">2</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">3</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        z = A[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">4</span>] == <span class="number">1'b1</span> &amp;&amp; CTRL_is_late_arriving == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">5</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Z = A[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> single_if_improved(A,C,CTRL_is_late_arriving,Z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">6</span>:<span class="number">1</span>]A;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">5</span>:<span class="number">1</span>]C;</span><br><span class="line"><span class="keyword">input</span> CTRL_is_late_arriving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Z,Z1;</span><br><span class="line"><span class="keyword">wire</span> Z2,prev_cond;</span><br><span class="line"><span class="keyword">always</span> @(A <span class="keyword">or</span> C) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">1</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        Z1 = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">2</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z1 = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">3</span>] == <span class="number">1'b1</span>)</span><br><span class="line">        z1 = A[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(C[<span class="number">5</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z1 = A[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Z1 = A[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> Z2 = A[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">assign</span> prev_cond = (C[<span class="number">1</span>]==<span class="number">1'b1</span>)||(C[<span class="number">2</span>]==<span class="number">1'b0</span>)||(C[<span class="number">3</span>]==<span class="number">1'b1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(C <span class="keyword">or</span> prev_cond <span class="keyword">or</span> CTRL_is_late_arriving <span class="keyword">or</span> Z1 <span class="keyword">or</span> Z2) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>((C[<span class="number">4</span>]==<span class="number">1'b1</span>)&amp;&amp;(CTRL_is_late_arriving==<span class="number">1'b0</span>))</span><br><span class="line">        <span class="keyword">if</span>(prev_cond) Z = Z1;</span><br><span class="line">        <span class="keyword">else</span> Z = Z2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Z = Z1;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>电路结构：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig4.png" alt="img"></p>
<h1 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h1><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> case_in_if_01(A,DATA_is_late_arriving,C,sel,Z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">8</span>:<span class="number">1</span>]A;</span><br><span class="line"><span class="keyword">input</span> DATA_is_late_arriving;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>]sel;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">5</span>:<span class="number">1</span>]C;</span><br><span class="line"></span><br><span class="line">ouput Z;</span><br><span class="line"><span class="keyword">reg</span> Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> C <span class="keyword">or</span> A <span class="keyword">or</span> DATA_is_late_arriving)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(C[<span class="number">1</span>])</span><br><span class="line">        Z = A[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">2</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">3</span>])</span><br><span class="line">        Z = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="number">3'b010</span>: Z = A[<span class="number">8</span>];</span><br><span class="line">            <span class="number">3'b011</span>: Z = DATA_is_late_arriving;</span><br><span class="line">            <span class="number">3'b101</span>: Z = A[<span class="number">7</span>];</span><br><span class="line">            <span class="number">3'b110</span>: Z = A[<span class="number">6</span>];</span><br><span class="line">            <span class="keyword">default</span>: Z = A[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (C[<span class="number">5</span>] == <span class="number">1'b0</span>)</span><br><span class="line">        Z = A[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">else</span> Z = A[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>对应的电路结构：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig5.png" alt="img"></p>
<p>修改后：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig6.png" alt="img"></p>
<h1 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h1><p>信号CONTROL到达时间较晚，如何修改能够提高电路性能？</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig7.png" alt="img"></p>
<p>如下修改，过复制数据路径，将CONTROL信号放到最后，通过先加后选的方式，改善选择信号的延时。</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig8.png" alt="img"></p>
<p>调整后的代码：</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig9.png" alt="img"></p>
<h1 id="范例5："><a href="#范例5：" class="headerlink" title="范例5："></a>范例5：</h1><p>假设A信号到来较晚，如何修改能够提高电路性能？</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig10.png" alt="img"></p>
<p>修改方法：</p>
<p>通过调整A信号的计算顺序，是信号A路上减少了一个加法器。</p>
<p><img src="https://sliu0827.github.io/source/images/RTL/1.RTL%E8%80%83%E8%99%91%E5%BB%B6%E6%97%B6/fig11.png" alt="fig11"></p>
<blockquote>
<p>参考：<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener">芯动力—硬件加速设计方法</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>SRAM_cell电学稳定性分析</title>
    <url>/2020/02/15/2020-02-15-SRAM_cell%E7%94%B5%E5%AD%A6%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>在SRAM中，读写操作是最基本的，为了保证读写功能可以正常实现，我们需要分开来分析测试读写操作的稳定性，本文便详细阐释了SRAM读写操作的电学稳定性。</em></p>
<a id="more"></a>



<h3 id="Read-and-Write-Operatioins"><a href="#Read-and-Write-Operatioins" class="headerlink" title="Read and Write Operatioins"></a><strong>Read and Write Operatioins</strong></h3><hr>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig1.png" alt="img"></p>
<center>Fig.1 SRAM memory cell</center>
图1为CMOS 6-T SRAM电路图，图2为其读写操作波形。





<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig2.png" alt="img"></p>
<center>Fig.2 Fundamental waveform of SRAM operation</center>
**当写****入数据“0”(W“0”)**时，word line(WL)被激活，bit line根据输入数据值被驱动到“H”和“L”状态。存储节点的电压发生翻转，输入数据写入到数据存储节点中。 



<p><strong>当从ce**</strong>ll中读“0”(R“0”)**时，所有bit line被预充为“H”，激活WL。原先保存在数据节点的数据使bit lines出现电压差。电压差通过灵敏放大器(sense amplifier)放大，保持的数据(retained data)被读出。</p>
<p><strong>当写入数据“1”到cell中，**</strong>且写入失败(W “1” write failure case)**时，存储节点(N0/N1)的电压没有翻转，正确的数据没有写入cell中。在下一个读周期，不正确的数据“0”被读出。</p>
<p><strong>当读数据“1”，**</strong>且读出失败(R1 read failure case<strong>**)</strong>时，存储节点的电压(N0/N1)发生翻转，存储节点的保持数据(retained data)被破坏。</p>
<p>图3为SRAM memory保持数据情形，存储节点N0和N1，保持相反的状态，“H”和“L”。word line 为“L”。</p>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig3.png" alt="img"></p>
<center>Fig.3 SRAM cell condition during data retention</center>
如下图4所示，Memory cell读过程中，右边的节点N1，状态为"H"，左边的节点状态为"L"。在读之前，bit lines被预充电到"H"状态。读的过程中，word lines变为"H"状态，存取管(access MOSs)导通打开。读cell电流Iread从access MOS到“L”-state的存储节点流动，对预充的bit line放电。



<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig4.png" alt="img"></p>
<center>Fig.4 Read operation of SRAM cell</center>
图5a电压波形是SRAM cell在正常读数据的过程中，每个存储节点的电压变化。正常读数据时，存储节点的电压不会发生翻转。图5b为memory cell正常操作的butterfly cruves，用来评估静态噪声裕量(SNM)。两条线之间有两个密闭空隙（space），意味着SRAM读操作的SNM是足够的。



<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig5.png" alt="img"></p>
<center>Fig.5 Voltage waveforms and butterfly curves during normal read operation. </center>
 <center> (a) SRAM cell nodes during normal read operation. (b) Butterfly curves to estimate SNM</center>
**在读操作期间，由于access MOS和driver MOS之间的电阻分压**，存储节点的“L"-state被提升。**如果存储节点电压“L”-state的提升值超过了由driver MOS,DR1和loadMOS，LD1组成的反相器的逻辑中点电压，保持数据将翻转****，被破坏(6a)**。这种情况就是memory cell读失败。图6b是memory cell读数据失败对应的butterfly curves，两条曲线之间只有一个空隙，SRAM能正常读的SNM是不够的。



<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig6.png" alt="img"></p>
<center>Fig.6 Voltage waveforms and butterfly curves during failure read operation. </center>
<center>  (a) SRAM cell nodes during failureread operation. (b) Butterfly curves to estimate SNM</center>
![img](https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig7.png)

<center>Fig.7 Write operation of SRAM cell</center>
关于写操作，如图7，在写之前，左边存储节点N0是“H” state，右边存储节点N1是“L” state。当要写的数据到达bit lines时，“H” state存储节点经过access MOS放电，写操作cell电流Iwrite,在图中用实线箭头标出。当“H”电位节点被放电至“L”电位时，节点的电压此时发生翻转，写操作完成(图8)。



<p><strong>在写的过程中，load MOS通过上拉电流Ipullup充电</strong>，如图3.7中虚线箭头所示。因此，<strong>如果load MOS充电的电流比access MOS放电电流大的话，存储节点“H”电位不会放电，节点电压不发生翻转，写操作失败(图9)</strong>。</p>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig8.png" alt="img"></p>
<center>Fig.8 SRAM cell nodes during normal write operation</center>
![img](https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig9.png)

<center>Fig.9 SRAM cell nodes during failure write operation</center>
### **Sum** 

<hr>
<p><strong>在SRAM cell 中，加强读操作和写操作稳定性的设计方法是一个矛盾的关系</strong>。例如，在表1中促使读操作和写操作更稳定的方法。所以，<strong>很难同时提高读和写操作的稳定性</strong>。在所有的130nm之前的传统制造工艺中，在SRAM cell中有更大的电压工作空间，可以同时保证稳定性，不会出问题。在更近的制造工艺中，随着MOSFETs中Vth变化(variation)，电压工作空间(operation margin)减小，SRAM cell中MOSFET电流随着Vth变化而波动(fluctuated)。</p>
<p>除此之外，Vth variations会破坏在读和写操作期间MOSFET电流的平衡。因此，在SRAM cell设计阶段，最大化SRAM cell的operatingmargin，包括读和写的margin是必不可少的。Vth是MOSFET的一个很好的参数表征，它几乎完全可以指示晶体管的性能。</p>
<center>Table.1 Drivability change to enhancestability of each operation</center>
![img](https://sliu0827.github.io/source/images/doc/Memory/2.SRAM_cell/fig10.png)



<p>为了实现最大化的operating-margins，需要更准确的SRAM operating margins，在本书第3章中，对于受MOSFET Vth variation而影响的SRAM operating margins分析做了进一步描述，这里不再细说。</p>
<p>[^Ref]: <em>Low power and reliable SRAM memory cell and array design[M]. Springer Science &amp; Business Media, 2011.</em></p>
]]></content>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>SRAM 基础</title>
    <url>/2020/02/12/2020-02-12-SRAM%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>“</strong> 介绍SRAM基本存储单元，也分析了其设计和读写过程。<strong>”</strong></p>
<p><em>01.最常见的SRAM cell，the full CMOS 6T 类型；</em></p>
<p><em>02.SRAM的读写过程；</em></p>
<p><em>03.执行读操作时最基本的电学稳定**特性，静态噪声裕量(SNM)</em></p>
<a id="more"></a>

<h3 id="SRAM-CELL"><a href="#SRAM-CELL" class="headerlink" title="SRAM CELL"></a>SRAM CELL</h3><hr>
<p>SRAM cell由一个基本的触发器（flip-flop）单元构成，即<strong>两个交叉耦合（cross coupled）的反相器</strong>，于flip-flop的存储结点存储逻辑值“0”或“1”。</p>
<p>最常用的SRAM cell是全部由MOS管构成的6个晶体管构成的互补逻辑电路（full CMOS 6-transistor），就SOC（system-on-chip）设计而言，由于full CMOS 6-T使用的工艺为平面CMOS工艺，便于生成制造，故最常使用。</p>
<p>主要组成：</p>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/1.SRAM%E5%9F%BA%E7%A1%80/fig2.1.png" alt="fig2.1"></p>
<center>Fig. 2.1 SRAM cell with the full CMOS 6-transistor (6-T)</center>
**两个反相器(load MOSFET(LD0)-driver MOSFET(DR0), LD1-DR)；**

<p><strong>两个导通管(access MOSFET AC0, AC1)连接到一对bit line(BT,BB)上，同时，导通管的栅端(gate)连接到word line(WL)；</strong></p>
<p>为构成一个flip-flop，<strong>其中一个反相器的输入和输出端需要分别连接到另一个反相器的输出和输入端，也即是交叉耦合</strong>。</p>
<h3 id="Basic-Operation-of-SRAM-Cell"><a href="#Basic-Operation-of-SRAM-Cell" class="headerlink" title="Basic Operation of SRAM Cell"></a>Basic Operation of SRAM Cell</h3><hr>
<p>Memory的基本排列构造（array structure）如下图2.2所示，整个memory由nxm位memory cell组成。</p>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/1.SRAM%E5%9F%BA%E7%A1%80/fig2.2.png" alt="fig2.2"></p>
<center>Fig. 2.2 Basic full CMOS cell array structure</center>
SRAM具体某一位cell的确定由横向和纵向上共同选中，横向上由**word line译码器（word decoder）**根据地址数据选择一排word line(WL),纵向上bit line控制电路由**预充电电路（precharge circuit），列选择器（Column multiplexer，MUX），灵敏放大器（sense amplifier ，SA)，输出电路（output FF）和写放大器（write amplifier，SA）**构成。详细的电路结构在图2.3中。



<p><img src="https://sliu0827.github.io/source/images/doc/Memory/1.SRAM%E5%9F%BA%E7%A1%80/fig2.3.png" alt="fig2.3"></p>
<center>Fig. 2.3 Column control circuits consisting of precharge circuit, column multiplexer (mux),sense amplifier (SA), output FF, and write amplifier (WA)</center>
下面介绍SRAM读写操作，如图2.4所示电压波形。**执行读操作需要给bit line先进行预充电（precharge），prechage电路平衡提升bit line的电位至VDD。****随后，word line置高，导通管打开，预先存储于存储节点的数据使cell产生一个小的电压变化（ΔVS）**。



<p><img src="https://sliu0827.github.io/source/images/doc/Memory/1.SRAM%E5%9F%BA%E7%A1%80/fig2.4.png" alt="fig2.4"></p>
<center>Fig. 2.4 Basic voltage waveform in read and write operation</center>
如果存储的数据为“1”，cell存储节点N0是低电压，N1是高电压。因为DR1没有打开，另一条bit line BB保持平衡时的电压，而BT的电压值则会减小ΔVS 。



<p>通过打开Column-select line for read(YSR)信号，由bit line构成的差分信号传输到灵敏放大器（sense amplifier）的输入端(ST/SB)，经放大后又由output FF锁存输出。如果存储的数据为“0”，与此相似，只不过将会是bit line BB的电压减少。</p>
<p><strong>执行写操作，同样也需要打开word line，在打开word line之前，将bit line电压平衡到VDD，由数据输入端过来的输入数据Din经由write amplifier（WA）传输至bit line</strong>。不同于读操作的是此时column 的选择由column-select signal for write (YSW)来控制。</p>
<p>Bit line电压变化后，使存储节点（N1，N2）的电压翻转，从而写入数据。最后，写操作完成时word line关闭。</p>
<h3 id="Electrical-Stability-at-Read-Operation-Static-Noise-Margin-and-β-Ratio"><a href="#Electrical-Stability-at-Read-Operation-Static-Noise-Margin-and-β-Ratio" class="headerlink" title="Electrical Stability at Read Operation:Static Noise Margin and β Ratio"></a>Electrical Stability at Read Operation:Static Noise Margin and β Ratio</h3><hr>
<p><strong>在正常读取数据模式下</strong>，假设node N0处于低电平，node N1处于高电平，字线被激活后，读电流（read current）由BT至N0流动，因此N0的电压会上升ΔVN（图2.4）。</p>
<p><strong>不正常读取操作时</strong>，ΔVN大于DR1的阈值电压（Vth），DR1打开随之N1的电压减小，又导致N0的电压增大，最后致使cell翻转。</p>
<p>因此我们需要通过设计来避免出现不正常的读操作，其中一个重要的衡量稳定性的参数便是静态噪声裕量（SNM）。<strong>SNM参数表征了在读操作期间，cell 出现翻转的电压裕量</strong>。为评估SNM，将word line 和一对bit line连接到VDD（图2.5）。</p>
<p>按如下方式进行仿真分析：</p>
<p>1.N0的电压由0V增加到VDD，同时测量N1的电压，绘制N1-N0的关系；</p>
<p>2.N1的电压由0V增加到VDD，同时测量N0的电压，绘制N0-N1的关系；</p>
<p>3.在曲线A和曲线B（或曲线C和D）中画出最大正方形。方形中较小那个的对角线就是SNM。</p>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/1.SRAM%E5%9F%BA%E7%A1%80/fig2.5.png" alt="fig2.5"></p>
<center>Fig. 2.5 Connections of the word line and a pair of bit lines to estimate the SNM</center>
如图2.6所示，曲线A和曲线B被称作蝶形曲线“butterfly curb”，图中列出了VDD=0.6V和1.1V的情况，SRAM的工作电压越低，静态噪声裕量SNM越小。



<p><strong>蝶形曲线的不对称性受存储单元MOS管的阈值电压（Vth）变动影响，变化（variation）增加不对称性增加，导致SNM减小</strong>。</p>
<p>Driver MOSFET的阈值电压（Vth）较低，会减小SNM。Driver MOS和access MOS的栅宽之比称作比例因子β。通过增加driver MOS的电流，减小access MOS的电流，从而限制了N0电压的上升值ΔVN ，<strong>因此β增大，SNM增大</strong>。一般情况下，SRAM cell中，比率β大于1.5。</p>
<p><img src="https://sliu0827.github.io/source/images/doc/Memory/1.SRAM%E5%9F%BA%E7%A1%80/fig2.6.png" alt="fig2.6"></p>
<center>Fig. 2.6 Butterfly curbs are shown at VDD 0.6V and 1.1V</center>
因为full CMOS 6-T memory 能在静态工作状态下保存数据，不需要额外的动态刷新。在读的时候，因为有电压相反的bit line信号配合输出给差分放大器，能在较短时间内获取数据。因此，SRAM在cache memory，mobile phone等等都都有应用，但SRAM cell 也需要在standby mode 下降低其保持数据所产生的功耗。

<p>[^Ref]: <em>Low power and reliable SRAM memory cell and array design[M]. Springer Science &amp; Business Media, 2011.</em></p>
]]></content>
      <tags>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>CMOS反相器之动态特性</title>
    <url>/2020/02/10/2020-02-10-CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%B9%8B%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CMOS反相器的性能：动态特性"><a href="#CMOS反相器的性能：动态特性" class="headerlink" title="CMOS反相器的性能：动态特性"></a>CMOS反相器的性能：动态特性</h2><hr>
<p>CMOS反相器的传播延时取决于它分别通过PMOS和NMOS管充放电负载电容C<sub>L</sub>所需要的时间。使C<sub>L</sub>尽可能小是实现高性能CMOS电路的关键。</p>
<a id="more"></a>

<h3 id="1-电容值分类"><a href="#1-电容值分类" class="headerlink" title="1.电容值分类"></a>1.电容值分类</h3><ul>
<li>栅漏电容C<sub>gd12</sub></li>
<li>扩散电容C<sub>db1</sub>和C<sub>db2</sub></li>
<li>连线电容C<sub>W</sub></li>
<li>扇出的栅电容C<sub>g3</sub>和C<sub>g4</sub></li>
</ul>
<p><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%B9%8B%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/clip_image001.png" alt="img"></p>
<h3 id="2-传播延时：一阶分析"><a href="#2-传播延时：一阶分析" class="headerlink" title="2.传播延时：一阶分析"></a>2.传播延时：一阶分析</h3><p>等效导通电阻R<sub>eq</sub>，反相器的总传播延时：t<sub>p</sub> = （t<sub>pHL</sub> + t<sub>pLH</sub>)/2，其中：<br>​    t<sub>pHL</sub>= 0.69 R<sub>eqn</sub>C<sub>L</sub><br>​    t<sub>pLH</sub>= 0.69 R<sub>eqp</sub>C<sub>L</sub></p>
<p><strong>减小门传播延时：</strong></p>
<ul>
<li><p>减小C<sub>L</sub>：负载电容由三个主要部分组成：内部的扩散电容、互连线电容和扇出电容。通过细致的版图设计有助于减少扩散电容和互连线电容</p>
</li>
<li><p>增加晶体管的W/L比：可以减小等效电阻，是最有力和最有效的性能优化工具。</p>
<p><font color="#dd0000">同时增加晶体管尺寸也会增加扩散电容，因而增加C<sub>L</sub>，当本征电容超过由连线和扇出行成的外部负载时，增加门的尺寸不再对减少延时有帮助。</font><br><font color="#dd0000">较宽的晶体管具有较大的栅电容，增加了驱动门的扇出系数，从而反过来影响它的速度。</font></p>
</li>
<li><p>提高VDD：牺牲功耗来换取性能</p>
</li>
</ul>
<h3 id="3-从设计角度考虑传播延时"><a href="#3-从设计角度考虑传播延时" class="headerlink" title="3.从设计角度考虑传播延时"></a>3.从设计角度考虑传播延时</h3><p><strong>NMOS和PMOS的比</strong><br>通常要求PMOS与NMOS的宽度比在3~3.5之间，使得设计反相器具有对称的VTC，并使得t<sub>pHL</sub> =t<sub>pLH</sub>。但如果对称性和噪声容限不是主要的考虑因素，可通过减小PMOS器件的宽度来加快反相器的速度。原因是，是PMOS较宽可以改善反相器的t<sub>pLH</sub> ，但它也由于产生较大的寄生电通而使tpHL 变差。</p>
<p><strong>考虑性能时反相器的尺寸的确定</strong></p>
<p>负载电容划分为：C<sub>L</sub> = C<sub>int</sub> + C<sub>ext</sub>，其中 C<sub>int</sub> 即本征输出电容， C<sub>ext</sub>是外部负载电容，来自扇出和导线电容。</p>
<p>$$<br>\begin{align<em>}<br>t_p &amp;= 0.69R_{eq}(C_{int}+C_{ext})=0.69R_{eq}C_{int}(1+C_{ext}/C_{int})\<br>&amp;= t_{p0}(1 + C_{ext}/C_{int})\<br>&amp;=  0.69(R_{ref}/S)(SCi_{ref})(1 + Cext /(SCiref))\<br>&amp;=  0.69R_{ref}Ci_{ref}(1+C_{ext}/SCi_{ref})\<br>&amp;=  t_{p0} (1 + C_{ext}/SCi_{ref})<br>\end{align</em>}<br>$$</p>
<p><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%B9%8B%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/math.png" alt="img"></p>
<p>Leads two important conclusions:</p>
<ul>
<li>反相器的本征延时tp0与门的尺寸无关，而只取决于工艺及方相器的版图；</li>
<li>使S无穷大将达到最大可能的性能改善，使延时减小到只有本征延时值。</li>
</ul>
<p><strong>确定反相器链的尺寸</strong></p>
<p>每一个反相器的最优尺寸是与它相邻的前后两个反相器尺寸的几何平均数，即每个反相器都具有相同的等效扇出，也就具有相同的延时。可以推导出尺寸系数f。</p>
<p><strong>选择一个反相器链的正确级数</strong></p>
<p>简化条件下可以得到最优的级数为N = ln(F)。</p>
<p>选择的扇出值大于最优值并不会过多的影响延时，但能减少所要求的缓冲器级数和实现面积。</p>
<p><strong>输入信号的上升-下降时间</strong></p>
<p>保持门的输入信号的上升时间小于或等于门的传播延时是很有利的。</p>
<p><strong>存在（长）互连线时的延时</strong></p>
<p>当门之间的距离进一步加大之后，互连线的电容和电阻就不容忽略，也使得导线延时在较长导线的总延时中总迅速占据主要地位。（延时表达式中有一个与导线长度呈线性关系和一个成平方关系的部分）</p>
<h3 id="4-功耗、能量和能量延时"><a href="#4-功耗、能量和能量延时" class="headerlink" title="4.功耗、能量和能量延时"></a>4.功耗、能量和能量延时</h3><p><strong>动态功耗</strong></p>
<p>反相器门开关过程中，由充放电电容引起的功耗</p>
<p><strong>设计技术</strong><br>改变器件尺寸并降低电源电压是减小一个逻辑电路能耗的非常有效的方法；<br>在最优值之外过多地加大晶体管尺寸会付出较大的能量代价。至今许多设计仍普采用这种方法；<br>考虑能量时的最优尺寸系数小于考虑性能时的最优尺寸系数</p>
<p><strong>直通功耗</strong><br>由于输入波形的上升和下降时间为零。开关过程中VDD和GND之间在短期内出现一条直流通路，此时NMOS和PMOS同时导通。直接通路电流引起功耗</p>
<p><strong>设计技术</strong><br>使输出的上升/下降时间大于输入的上升/下降时间可以使短路功耗减到最小；</p>
<p><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%B9%8B%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/clip_image002.png" alt="img"></p>
<p>从全局的角度看，应该使所有信号的上升/下降时间保持在一定范围内不变。当负载电容太小时，功耗主要来自于短路电流，对于非常大的负载电容值，功耗主要是电容充电和放电产生。</p>
<p><strong>静态功耗</strong></p>
<p>由于泄漏电流流过位于晶体管源（或漏）与衬底之间的反相偏置的二极管结而形成的静态功耗；晶体管的亚阈值电流。</p>
<p><strong>设计技术</strong></p>
<p>阈值电压的选择代表了在性能和静态功耗之间的权衡取舍。降低电源电压而保持阈值电压不变会造成性能的严重损失，阈值电压的最低值又是由所允许的亚阈值漏电电流的数量所决定的。</p>
<p>通过权衡选择正确的电源值和阈值电压值；</p>
<p>当存在较大静态功耗时，使不工作的模块暂时断电以减少静态功耗。</p>
<p><strong>综合考虑</strong></p>
<p>CMOS反相器的总功耗可以分为三部分的和：</p>
<p><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D%E4%B9%8B%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7/clip_image003.png" alt="img"></p>
<p>其中Pdyn为电容功耗，Pdp为直接通路功耗，Pstat为漏电功耗。</p>
<p><strong>功耗—延时积或每次操作的能量损耗</strong></p>
<p>衡量了开关门所需要的能量</p>
<p><strong>能量—延时积</strong></p>
<p>衡量电源电压（即性能）与延时之间的矛盾关系</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><ul>
<li>静态CMOS反相器，组合了一个上拉PMOS和一个下拉的NMOS，由于PMOS有较低的电流驱动能力，通常使它比NMOS宽。</li>
<li>理想的电压传输特性。逻辑摆幅等于电源电压并且与晶体管尺寸无关。噪声容限接近VDD/2.稳态响应不受扇出的影响。</li>
<li>传播延时主要由充放电负载电容CL所需要的时间决定。一阶近似为，tp=0.69CL((Reqn + Reqp)/2),使负载电容较小是实现高性能电路的最有效手段。</li>
<li>功耗主要由充放电负载电容时消耗的动态功耗决定。功耗与电路的活动性成正比。开关通断期间的直接通路功耗可以通过对信号斜率的仔细修正来限制。静态功耗通常可以忽略，但由于阈值电流的原因可能成为一个主要因素。</li>
<li>工艺尺寸变小是减少一个门的面积、传播延时以及功耗的有效手段。同时降低电源电压，影响更大。</li>
<li>互连线的影响将在总延时和总性能中逐渐占有更大的比例。</li>
</ul>
<p>参考资料：</p>
<blockquote>
<p>Rabaey J M, Chandrakasan A P, Nikolić B. Digital integrated circuits: a design perspective[M]. Upper Saddle River, NJ: Pearson Education, 2003.</p>
</blockquote>
]]></content>
      <tags>
        <tag>数字集成电路设计基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog HDL 基础</title>
    <url>/2020/02/09/2020-02-09-Verilog%20HDL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Verilog-HDL-语言的特点"><a href="#Verilog-HDL-语言的特点" class="headerlink" title="Verilog HDL 语言的特点"></a>Verilog HDL 语言的特点</h1><p><strong>互连（connectivity）</strong>：网络数据类型表示结构实体（例如门）之间的物理连接，不能存储值，由驱动器（例如门或连续赋值语句，assign）驱动。常见类型包括wire型和tri型。</p>
<p><strong>并发</strong>（concurrency）：可以有效地描述并行的硬件系统 </p>
<p><strong>时间</strong>（time）：定义了绝对和相对的时间度量，可综合操作符具有物理延迟</p>
<p><strong>可综合</strong>：always、if-else、case、assgin</p>
<p><strong>不可综合</strong>：function、for、fork-join、while</p>
<a id="more"></a>

<h1 id="常见可综合语法与硬件电路的关系"><a href="#常见可综合语法与硬件电路的关系" class="headerlink" title="常见可综合语法与硬件电路的关系"></a>常见可综合语法与硬件电路的关系</h1><h2 id="if-else相关语句的硬件结构映射及优化"><a href="#if-else相关语句的硬件结构映射及优化" class="headerlink" title="if-else相关语句的硬件结构映射及优化"></a>if-else相关语句的硬件结构映射及优化</h2><p>对应的硬件结构是多路选择器（Multiplexing Hardware）</p>
<ul>
<li>需要根据输入约束，小心设计：先“加”后“选”，先“选”后“加”</li>
</ul>
<img src="https://sliu0827.github.io/source/images/RTL/0.Verilog HDL基础/clip_image001.png" alt="img" style="zoom:80%;" />

<ul>
<li><p>单if语句，无优先级的判断结构</p>
</li>
<li><p>多if语句，具有优先级的判断结构</p>
<p>  最后一级选择信号具有最高优先权；<br>  具有优先级的多选择结构会消耗组合逻辑</p>
</li>
</ul>
<img src="https://sliu0827.github.io/source/images/RTL/0.Verilog HDL基础/clip_image002.png" alt="img" style="zoom: 150%;" />

<h2 id="case相关语句的硬件结构映射及优化"><a href="#case相关语句的硬件结构映射及优化" class="headerlink" title="case相关语句的硬件结构映射及优化"></a>case相关语句的硬件结构映射及优化</h2><p>对应的硬件结构是无优先级的判断结构，与单if语句的区别在于各条件互斥，多用于指令译码电路</p>
<h2 id="慎用latch"><a href="#慎用latch" class="headerlink" title="慎用latch"></a>慎用latch</h2><ul>
<li><p>综合器很难解释latch，因此，除非特殊用途，一般避免引入latch。</p>
<img src="https://sliu0827.github.io/source/images/RTL/0.Verilog HDL基础/clip_image003.png" alt="img"  />
latch由电平触发，非同步控制。DFF由时钟边沿触发，同步控制。
</li>
<li><p>在使能信号有效时，latch相当于通路，无效时latch保持输出数据的当前值。因此latch容易产生毛刺（glitch），DFF则不易产生毛刺。latch将静态时序分析变得极为复杂。<br> 一般的设计规则是：在绝大多数设计中避免产生latch。latch最大的危害在于不能过滤毛刺，这对于下一级电路是极其危险的，所以只要能用DFF的地方，就不用latch。</p>
</li>
<li><p>易引入latch的途径：使用不完备的条件判断语句</p>
</li>
<li><p>防止产生非目的性latch的措施： </p>
<pre><code>使用完备的if…else语句
  为每个输入条件设计输出操作，为case语句设置default操作
  仔细检查综合器生成的报告，latch会以warning的形式报告</code></pre></li>
<li><p>综合器指令，full-case和parallel-case</p>
<p>Full-case：告诉综合器，当前case结构所列条件已完备</p>
<p>Parallel-case：告诉DC，所有条件互斥，且并行，无优先权</p>
</li>
</ul>
<h2 id="逻辑复制，均衡负载"><a href="#逻辑复制，均衡负载" class="headerlink" title="逻辑复制，均衡负载"></a>逻辑复制，均衡负载</h2><p>通过逻辑复制，降低关键信号的扇出，进而降低该信号的传播延迟，提高电路性能。</p>
<img src="https://sliu0827.github.io/source/images/RTL/0.Verilog HDL基础/clip_image004.png" alt="img " style="zoom:80%;" />

<h2 id="资源共享，减小面积"><a href="#资源共享，减小面积" class="headerlink" title="资源共享，减小面积"></a>资源共享，减小面积</h2><img src="https://sliu0827.github.io/source/images/RTL/0.Verilog HDL基础/clip_image005.png" alt="img " style="zoom:80%;" />

<h2 id="资源顺序重排，降低传播延时"><a href="#资源顺序重排，降低传播延时" class="headerlink" title="资源顺序重排，降低传播延时"></a>资源顺序重排，降低传播延时</h2><img src="https://sliu0827.github.io/source/images/RTL/0.Verilog HDL基础/clip_image006.png" alt="img" style="zoom:80%;" />

<h2 id="同步复位与异步复位"><a href="#同步复位与异步复位" class="headerlink" title="同步复位与异步复位"></a>同步复位与异步复位</h2><h2 id="少用“：？”赋值语句"><a href="#少用“：？”赋值语句" class="headerlink" title="少用“：？”赋值语句"></a>少用“：？”赋值语句</h2><p>使用always用于逻辑运算，关于assign，仅用于信号连接，难以阅读，且多层嵌套后很难被综合其解释</p>
<h1 id="可综合风格"><a href="#可综合风格" class="headerlink" title="可综合风格"></a>可综合风格</h1><h2 id="完整的always敏感信号列表"><a href="#完整的always敏感信号列表" class="headerlink" title="完整的always敏感信号列表"></a>完整的always敏感信号列表</h2><p>所有的组合逻辑或锁存的always结构必须有敏感信号列表。这个敏感信号列表必须包含所有的输入信号</p>
<p><em>原因：综合过程将产生一个取决于除开敏感信号列表中所有其他值的结构，将可能在行为仿真和门级仿真间产生潜在的适配。</em></p>
<h2 id="每个always敏感信号列表对应一个时钟"><a href="#每个always敏感信号列表对应一个时钟" class="headerlink" title="每个always敏感信号列表对应一个时钟"></a>每个always敏感信号列表对应一个时钟</h2><p>在综合过程中，每个Verilog always敏感信号列表只能对应一个时钟。</p>
<p><em>原因：这是将每一个过程限制在单一寄存器类型的要求。</em></p>
<h2 id="在时序电路中必须使用非阻塞赋值（-lt-），组合逻辑电路必须使用阻塞赋值（-）。"><a href="#在时序电路中必须使用非阻塞赋值（-lt-），组合逻辑电路必须使用阻塞赋值（-）。" class="headerlink" title="在时序电路中必须使用非阻塞赋值（&lt;=），组合逻辑电路必须使用阻塞赋值（=）。"></a>在时序电路中必须使用非阻塞赋值（&lt;=），组合逻辑电路必须使用阻塞赋值（=）。</h2><h1 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h1><h2 id="分开异步逻辑与同步逻辑"><a href="#分开异步逻辑与同步逻辑" class="headerlink" title="分开异步逻辑与同步逻辑"></a>分开异步逻辑与同步逻辑</h2><p>建议分开异步逻辑与同步逻辑</p>
<p><em>原因：避免综合时的问题，简化约束和编码难度。</em></p>
<h2 id="分开控制逻辑和存储器"><a href="#分开控制逻辑和存储器" class="headerlink" title="分开控制逻辑和存储器"></a>分开控制逻辑和存储器</h2><p>建议控制逻辑和存储器逻辑分成独立的模块</p>
<p><em>原因：便于高层的存储器模块的使用和便于重新描述为不同的存储器类型。</em></p>
<blockquote>
<p>参考：<a href="https://www.icourse163.org/course/SWJTU-1207492806?tid=1207824209" target="_blank" rel="noopener" title="芯动力--硬件加速设计方法">芯动力–硬件加速设计方法</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>RTL</tag>
      </tags>
  </entry>
  <entry>
    <title>CMOS反相器介绍</title>
    <url>/2020/02/08/2020-02-08-CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>

<h3 id="0-CMOS设计指标"><a href="#0-CMOS设计指标" class="headerlink" title="0.CMOS设计指标"></a>0.CMOS设计指标</h3><h6 id="设计指标："><a href="#设计指标：" class="headerlink" title="设计指标："></a>设计指标：</h6><ul>
<li>成本：用复杂性和面积来表示</li>
<li>完整性和稳定性：用静态（即稳态）特性来表示</li>
<li>性能：由动态（即瞬态）响应决定</li>
<li>能量效率：由能耗和功耗决定</li>
</ul>
<h3 id="1-静态CMOS反相器"><a href="#1-静态CMOS反相器" class="headerlink" title="1.静态CMOS反相器"></a>1.静态CMOS反相器</h3><h6 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h6><ul>
<li>输出高电平和低电平分别为VDD和GND。没有阈值损失，通过PMOS传高电平VDD，通过NMOS传低电平GND。</li>
<li>无比逻辑。晶体管的尺寸可采用最小尺寸。</li>
<li>稳态时在输出和VDD或GND之间总存在一条具有有限电阻的通路。具有低输出阻抗。</li>
<li>CMOS反相器的输入电阻极高。由于MOS管的栅实际上是一个绝缘体，因此不去任何DC（直流）输入电流。</li>
<li>无静态功耗。稳态工作情况下电源和地线之间没有直接的通路（即此时输入和输出保持不变）。</li>
</ul>
<h6 id="电压传输特性（VTC）："><a href="#电压传输特性（VTC）：" class="headerlink" title="电压传输特性（VTC）："></a>电压传输特性（VTC）：</h6><p><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D/fig1.png#pic_center" alt="电压传输特性" title="电压传输特性"></p>
<ul>
<li>PMOS的静态特性曲线可由镜像平移得到，观察两种MOS管的VTC曲线可得到CMOS反相器的传输特性<br><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D/fig2.png#pic_center" alt="CMOS反相器传输特性" title="CMOS反相器传输特性"></li>
<li>瞬态特性，主要由CL决定。CL主要包括NMOS和PMOS的漏扩散电容、连线电容和扇出门的输入电容。</li>
<li>低到高，门的响应时间由通过RP充电电容CL决定，传播延时正比于时间常数RPCL：<br>快速门设计方法：减小输出电容；减小晶体管导通电阻（加大器件的W/L）</li>
<li>高到低，门的响应时间由电容CL通过电阻Rn对地放电决定，传播延时正比于时间常数RnCL</li>
</ul>
<h3 id="2-CMOS反相器稳定性的评估——静态特性"><a href="#2-CMOS反相器稳定性的评估——静态特性" class="headerlink" title="2.CMOS反相器稳定性的评估——静态特性"></a>2.CMOS反相器稳定性的评估——静态特性</h3><h6 id="开关阈值：VM定义为Vin-Vout的点。"><a href="#开关阈值：VM定义为Vin-Vout的点。" class="headerlink" title="开关阈值：VM定义为Vin=Vout的点。"></a>开关阈值：VM定义为Vin=Vout的点。</h6><p>一般希望开关阈值VM处于电压摆幅的中点（VDD/2）附近，这样可使高噪声容限和低噪声容限具有相近的值。</p>
<ul>
<li><p>设计技术：<br>为使得噪声容限最大并得到对称的特性，建议使PMOS比NMOS部分宽以均衡晶体管的驱动强度。<br><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D/fig3.png#pic_center" alt="反相器开关阈值变化" title="反相器开关阈值变化"></p>
</li>
<li><p>VM对器件比值的变化不敏感<br>设计中使PMOS管的宽度小于完全对称时所要求的值是可以接受的</p>
</li>
<li><p>改变Wp和Wn比值的影响使VTC的过渡区平移<br>增加PMOS或NMOS宽度分别使VM移向VDD或GND。这种不对称设计在某些设计中使所期望的。</p>
</li>
</ul>
<h6 id="噪声容限"><a href="#噪声容限" class="headerlink" title="噪声容限"></a>噪声容限</h6><ul>
<li>对VTC曲线做逐段近似简化，得出VIH和VIL，推导出高电平噪声容限和低电平噪声容限：<br>NMH = VDD - VIH , NML = VIL<br><img src="https://sliu0827.github.io/source/images/doc/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/CMOS%E5%8F%8D%E7%9B%B8%E5%99%A8%E4%BB%8B%E7%BB%8D/fig4.png#pic_center" alt="噪声容限" title="噪声容限"></li>
</ul>
<h6 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h6><ul>
<li><p>器件参数的变化<br>静态CMOS反相器对这些变化不敏感，可以在一个很宽的工作条件下工作。</p>
</li>
<li><p>降低电源电压（在接近100mV的时候，门的特性变差）<br>不加区分的降低电源电压虽然对减少能耗有正面影响，但会使门的延时加大；<br>一旦电源电压和本征电压（阈值电压）变得可以比拟，DC特性对器件参数的变化会变得更加敏感；降低电源电压意味着减小信号摆幅，可以帮助减小内部噪声，但它使设计对并不减小的外部噪声源更加敏感</p>
</li>
</ul>
<p>参考资料：</p>
<blockquote>
<p>Rabaey J M, Chandrakasan A P, Nikolić B. Digital integrated circuits: a design perspective[M]. Upper Saddle River, NJ: Pearson Education, 2003.</p>
</blockquote>
]]></content>
      <tags>
        <tag>数字集成电路设计基础</tag>
      </tags>
  </entry>
  <entry>
    <title>sed实例</title>
    <url>/2020/02/07/2020-02-07-sed%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GNU-sed实例教程"><a href="#GNU-sed实例教程" class="headerlink" title="GNU sed实例教程"></a>GNU sed实例教程</h1><blockquote>
<p>sed (stream editor) is a non-interactive command-line text editor.</p>
</blockquote>
<p>官方的定义是非交互地命令行文本编辑器。而我觉得描述成“行内文本插入、删除、替换的小工具“更容易理解。</p>
<p>说到”行内“，即以一行文本为单位进行处理。sed的工作模式如下图，读入一行文本到内部的buffer，执行处理文本命令，输出到屏幕。然后读入下一行文本，进行下一轮处理。</p>
<a id="more"></a>

<h2 id="sed使用方法"><a href="#sed使用方法" class="headerlink" title="sed使用方法"></a>sed使用方法</h2><p>sed使用格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -option &#39;cmd&#39; file</span><br></pre></td></tr></table></figure>

<p>其中，-option是sed的一些选项，’cmd’是处理文本的命令，如插入、删掉、替换等，file是待处理的文件。</p>
<p>cmd一般用单引号括起来，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;[line num]X[options]&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>line num是指定待处理的单行或几行。如果不指定行号，即为所有行。</li>
<li>X是执行的命令，如a（append）、d（delete）、i（insert）、s（search and replace）等。</li>
<li>options是指某些命令后可以带额外的参数。</li>
</ul>
<h2 id="sed基本用法示例"><a href="#sed基本用法示例" class="headerlink" title="sed基本用法示例"></a>sed基本用法示例</h2><h6 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h6><p>第一行插入日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;1i &#x2F;&#x2F;2019-2-13&#39; rtl.v</span><br></pre></td></tr></table></figure>

<h6 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h6><p>删除`timescale 1ns/100ps行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;\x60timescale&#x2F;d&#39;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>`用ASCII码0x60转义。</li>
<li>/xxx/是用正则的方式来指定要处理哪些行，也可以理解成包含xxx的行。</li>
</ol>
<h6 id="示例三："><a href="#示例三：" class="headerlink" title="示例三："></a>示例三：</h6><p>endmodule后面加// xxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;endmodule&#x2F;a &#x2F;&#x2F; xxx&#39; rtl.v</span><br></pre></td></tr></table></figure>

<h6 id="示例四："><a href="#示例四：" class="headerlink" title="示例四："></a>示例四：</h6><p>把output wire修改成output reg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;output&#x2F;s&#x2F;wire&#x2F;reg&#x2F;&#39; rtl.v</span><br></pre></td></tr></table></figure>

<h6 id="示例五："><a href="#示例五：" class="headerlink" title="示例五："></a>示例五：</h6><p>看看analog verilog model文件中有哪些module</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;&#x2F;^module&#x2F;p&#39; ana_v.v</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>-n是取消默认的打印，即仅打印匹配的行。</li>
<li>p是打印命令。</li>
</ol>
<h6 id="示例六："><a href="#示例六：" class="headerlink" title="示例六："></a>示例六：</h6><p>把逗号分隔的端口或者变量分成多行书写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;s&#x2F;,&#x2F;,\n&#x2F;g&#39; rtl.v</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>\n是回车符，用来换行</li>
<li>g是指行内替换多次，如果不加g则替换一次。</li>
</ol>
<h6 id="示例七："><a href="#示例七：" class="headerlink" title="示例七："></a>示例七：</h6><p>统计rtl的行数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;$&#x3D;&#39; rtl.v</span><br></pre></td></tr></table></figure>

<h6 id="示例八："><a href="#示例八：" class="headerlink" title="示例八："></a>示例八：</h6><p>把//aa的下一行中的assign加上延时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;\&#x2F;\&#x2F;aa&#x2F;&#123;n;s&#x2F;assign&#x2F;assign #1&#x2F;&#125;&#39; rtl.v</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>n是跳转到下一行，再执行后面的命令。</li>
</ol>
<h2 id="sed高级用法示例"><a href="#sed高级用法示例" class="headerlink" title="sed高级用法示例"></a>sed高级用法示例</h2><p>sed内部有两个存储空间，模式空间（pattern space）和保持空间（hold space）。模式空间就是上面提到的“行buffer”，而保持空间可以理解为另一个buffer，可以暂存任何临时数据。你可以想像成CPU的两个寄存器，通过类似汇编的指令来操作。</p>
<ul>
<li>g 将hold space中的内容拷贝到pattern space中</li>
<li>G 将hold space中的内容追加到pattern space中</li>
<li>h 将pattern space中的内容拷贝到hold space中</li>
<li>H 将pattern space中的内容追加到hold space中</li>
<li>d 删除multiline pattern中的所有行，并读入下一新行到pattern中</li>
<li>D 删除multiline pattern中的第一行</li>
<li>x 交换保持空间和模式空间的内容</li>
</ul>
<h6 id="示例九："><a href="#示例九：" class="headerlink" title="示例九："></a>示例九：</h6><p>删除rtl中的多行注释/* … */</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n script</span><br><span class="line"></span><br><span class="line">     1	&#x2F;\&#x2F;\*&#x2F;!&#123;p;d&#125;</span><br><span class="line">     2	:a</span><br><span class="line">     3	&#x2F;\*\&#x2F;&#x2F;!&#123;N;ba&#125;</span><br><span class="line">     4	s&#x2F;\&#x2F;\*.*\*\&#x2F;&#x2F;&#x2F;</span><br><span class="line">     5	p</span><br><span class="line"></span><br><span class="line">sed -nf script rtl.v</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>第1行，当没有遇到/*的行时，先输出，然后d忽略掉下方的其它sed命令，退出本次处理。只有遇到/*才开执行后续的命令。</li>
<li>第2行，:a设置标签</li>
<li>第3行，如果没有遇到*/，就把内容追加到pattern space</li>
<li>第4行，遇到*/后，执行查找替换，把/* … */删除</li>
<li>第5行，输出删除注释后的rtl</li>
<li>由于sed正则没有非贪婪模式，不然就可以直接全部读到pattern space再用正则。</li>
<li>-f选项是指sed命令写在脚本里，好处是不需要考虑shell的转义，写多个命令时比较方便。</li>
</ol>
<h6 id="示例十："><a href="#示例十：" class="headerlink" title="示例十："></a>示例十：</h6><p>交换rtl中的相邻两行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;&#123;h;n;G;p&#125;&#39; rtl.v</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ol>
<li>h把第一行存入hold space</li>
<li>n读入第二行到pattern space（覆盖掉第一行）</li>
<li>G把hold space中的内容追加到pattern space</li>
<li>p输出</li>
</ol>
<blockquote>
<p>《GNU sed, a stream editor 》  version 4.5, 30 March 2018  by Ken Pizzini, Paolo Bonzini  （P85）</p>
</blockquote>
<blockquote>
<p>本文转载自:<a href="http://exasic.com" target="_blank" rel="noopener" title="ExASIC">ExASIC</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
